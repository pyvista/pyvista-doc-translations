<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Basic API Usage &#8212; pyvista-doc-translations  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="basic-api-usage">
<h1>Basic API Usage<a class="headerlink" href="#basic-api-usage" title="Link to this heading">¶</a></h1>
<p>PyVista provides tools to get started with just about any VTK dataset
and wrap that object into an easily accessible data object.
Whether you are new to the VTK library or a power user, the best place to
get started is with PyVista’s <code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.wrap()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.read()</span></code>
functions to either wrap a VTK data object in memory or read a VTK or
VTK-friendly file format.</p>
<section id="wrapping-a-vtk-data-object">
<h2>Wrapping a VTK Data Object<a class="headerlink" href="#wrapping-a-vtk-data-object" title="Link to this heading">¶</a></h2>
<p>The wrapping function <code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.wrap()</span></code> is usable from the top level of
PyVista. This allows users to quickly wrap any VTK dataset they have as a
PyVista object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vtk</span>
<span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>

<span class="n">stuff</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkPolyData</span><span class="p">()</span>
<span class="n">better</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">stuff</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="reading-a-vtk-file">
<h2>Reading a VTK File<a class="headerlink" href="#reading-a-vtk-file" title="Link to this heading">¶</a></h2>
<p>PyVista provides a convenience function to read VTK file formats into their
respective PyVista data objects. Simply call the <code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.read()</span></code> function
passing the filename:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;my_strange_vtk_file.vtk&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="accessing-the-wrapped-data-object">
<h2>Accessing the Wrapped Data Object<a class="headerlink" href="#accessing-the-wrapped-data-object" title="Link to this heading">¶</a></h2>
<p>Now that you have a wrapped VTK data object, you can start accessing
and modifying the dataset. Some of the most common properties to
access include the points and point/cell data (the data attributes
assigned to the nodes or cells of the mesh respectively).</p>
<p>First, check out some common meta-properties:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span> <span class="k">as</span> <span class="nn">pv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="kn">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_airplane</span><span class="p">()</span>

<span class="go">Inspect how many cells are in this mesh</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">n_cells</span>
<span class="go">2452</span>

<span class="go">Inspect how many points are in this mesh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">n_points</span>
<span class="go">1335</span>

<span class="go">What about scalar arrays? Are there any?</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">n_arrays</span>
<span class="go">0</span>

<span class="go">What are the mesh bounds?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">bounds</span>
<span class="go">BoundsTuple(x_min =  139.06100463867188,</span>
<span class="go">            x_max = 1654.9300537109375,</span>
<span class="go">            y_min =   32.09429931640625,</span>
<span class="go">            y_max = 1319.949951171875,</span>
<span class="go">            z_min =  -17.741199493408203,</span>
<span class="go">            z_max =  282.1300048828125)</span>

<span class="go">Where is the center of this mesh?</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">center</span>
<span class="go">(897.0, 676.02, 132.19)</span>
</pre></div>
</div>
<p>Access the points by fetching the <code class="xref py py-attr docutils literal notranslate"><span class="pre">points</span></code> attribute on any PyVista mesh
as a <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">the_pts</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">the_pts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">the_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">array([[896.994 ,  48.7601,  82.2656],</span>
<span class="go">       [906.593 ,  48.7601,  80.7452],</span>
<span class="go">       [907.539 ,  55.4902,  83.6581],</span>
<span class="go">       [896.994 ,  55.4902,  85.3283],</span>
<span class="go">       [896.994 ,  42.8477,  77.825 ]], dtype=float32)</span>
</pre></div>
</div>
<p>Accessing the different data attributes on the nodes and cells of the mesh
is interfaced via dictionaries with callbacks to the VTK object.
These dictionaries of the different point and cell arrays can be directly
accessed and modified as NumPy arrays. In the example below, we load a dataset,
access an array on that dataset, then add some more data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_uniform</span><span class="p">()</span>

<span class="go">Fetch a data array from the point data dictionary</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">point_data</span><span class="p">[</span><span class="s1">&#39;Spatial Point Data&#39;</span><span class="p">]</span>

<span class="go">Assign a new array to the cell data:</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">n_cells</span><span class="p">)</span>

<span class="go">Don&#39;t remember if your array is point or cell data? You can</span>
<span class="go">directly query the mesh object and access the array from the</span>
<span class="go">dataset.</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
<span class="go">True</span>

<span class="go">Or maybe you just want to add an array where it fits.</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="p">[</span><span class="s1">&#39;new-array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">n_points</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="plotting">
<h2>Plotting<a class="headerlink" href="#plotting" title="Link to this heading">¶</a></h2>
<p>PyVista includes numerous plotting routines that are intended to be intuitive
and highly controllable with <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> similar syntax and keyword
arguments.</p>
<p>To get started, try out the <code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.plot()</span></code> convenience method
that is bound to each PyVista data object.</p>
<p>You can also create a plotter object to fine tune the scene. First,
instantiate a plotter such as <code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.Plotter</span></code> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">pyvistaqt.BackgroundPlotter</span></code>.  The <code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.Plotter</span></code>
will create a rendering window that will pause the execution of the
code after calling <code class="xref py py-func docutils literal notranslate"><span class="pre">show()</span></code>.</p>
<p>Optionally <code class="xref py py-func docutils literal notranslate"><span class="pre">show()</span></code> can return
the last used camera position of the rendering window in case you want
to choose a camera position and use it again later. The camera
position is also available as the <code class="xref py py-attr docutils literal notranslate"><span class="pre">camera_position</span></code> attribute of the plotter (even
after it’s closed).</p>
<p>You can then use this cached camera position for additional plotting
without having to manually interact with the plotting window:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># reuse the camera position from the previous plotter</span>
<span class="n">cpos</span> <span class="o">=</span> <span class="n">plotter</span><span class="o">.</span><span class="n">camera_position</span>
<span class="n">plotter</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">Plotter</span><span class="p">(</span><span class="n">off_screen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">camera_position</span> <span class="o">=</span> <span class="n">cpos</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">screenshot</span><span class="o">=</span><span class="s1">&#39;airplane.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Be sure to check out all the available plotters and their options for
your use case:</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.Plotter</span></code>: The standard plotter that pauses the code
until closed.</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvistaqt.BackgroundPlotter</span></code>: Creates a rendering window that
is interactive and does not pause the code execution (for more
information see the <a class="reference external" href="https://qtdocs.pyvista.org/">pyvistaqt</a> library)</p></li>
</ul>
</section>
<section id="exporting">
<h2>Exporting<a class="headerlink" href="#exporting" title="Link to this heading">¶</a></h2>
<p>Any PyVista mesh object can be saved to a VTK file format using
<code class="xref py py-func docutils literal notranslate"><span class="pre">save()</span></code>. For example, the mesh in the
code block above could be saved like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mesh</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;mesh.vtk&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Or since that mesh is <code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code>, we could use the <code class="docutils literal notranslate"><span class="pre">.vtp</span></code>,
<code class="docutils literal notranslate"><span class="pre">.stl</span></code>, or <code class="docutils literal notranslate"><span class="pre">.ply</span></code> formats as well.
For more details on which formats are supported in the <code class="docutils literal notranslate"><span class="pre">.save()</span></code> method,
please refer to the docs for that method on each mesh type.</p>
<p>Also note that we can export any PyVista mesh to any file format supported by
<a class="reference external" href="https://github.com/nschloe/meshio">meshio</a>. Meshio supports many formats
including: Abaqus, Ansys msh, AVS-UCD, CGNS, DOLFIN XML, Exodus, FLAC3D, H5M,
Kratos/MDPA, Medit, MED/Salome, Gmsh (versions 2 and 4), OBJ, OFF, PERMAS,
PLY, STL, TetGen .node/.ele, SVG (2D only, output only), UGRID, WKT (TIN),
XDMF, and more.</p>
<p>To save a PyVista mesh using <code class="docutils literal notranslate"><span class="pre">meshio</span></code>, use <code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.save_meshio()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pv</span><span class="o">.</span><span class="n">save_meshio</span><span class="p">(</span><span class="s2">&quot;mesh.obj&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">pyvista-doc-translations</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2021, Tetsuo Koyama.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 9.0.4</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../../../_sources/pyvista/doc/source/user-guide/simple.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>