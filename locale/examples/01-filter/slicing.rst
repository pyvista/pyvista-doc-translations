
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/01-filter/slicing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_01-filter_slicing.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_01-filter_slicing.py:


.. _slice_example:

Slicing
~~~~~~~

Extract thin planar slices from a volume.

.. GENERATED FROM PYTHON SOURCE LINES 9-15

.. code-block:: default

    import matplotlib.pyplot as plt
    import numpy as np

    import pyvista as pv
    from pyvista import examples








.. GENERATED FROM PYTHON SOURCE LINES 17-26

PyVista meshes have several slicing filters bound directly to all datasets.
These filters allow you to slice through a volumetric dataset to extract and
view sections through the volume of data.

One of the most common slicing filters used in PyVista is the
:func:`pyvista.DataSetFilters.slice_orthogonal` filter which creates three
orthogonal slices through the dataset parallel to the three Cartesian planes.
For example, let's slice through the sample geostatistical training image
volume. First, load up the volume and preview it:

.. GENERATED FROM PYTHON SOURCE LINES 26-34

.. code-block:: default


    mesh = examples.load_channels()
    # define a categorical colormap
    cmap = plt.cm.get_cmap("viridis", 4)


    mesh.plot(cmap=cmap)




.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_001.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 35-38

Note that this dataset is a 3D volume and there might be regions within this
volume that we would like to inspect. We can create slices through the mesh
to gain further insight about the internals of the volume.

.. GENERATED FROM PYTHON SOURCE LINES 38-44

.. code-block:: default


    slices = mesh.slice_orthogonal()

    slices.plot(cmap=cmap)





.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_002.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 45-46

The orthogonal slices can be easily translated throughout the volume:

.. GENERATED FROM PYTHON SOURCE LINES 46-49

.. code-block:: default


    slices = mesh.slice_orthogonal(x=20, y=20, z=30)
    slices.plot(cmap=cmap)



.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_003.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 50-53

We can also add just a single slice of the volume by specifying the origin
and normal of the slicing plane with the :func:`pyvista.DataSetFilters.slice`
filter:

.. GENERATED FROM PYTHON SOURCE LINES 53-61

.. code-block:: default


    # Single slice - origin defaults to the center of the mesh
    single_slice = mesh.slice(normal=[1, 1, 0])

    p = pv.Plotter()
    p.add_mesh(mesh.outline(), color="k")
    p.add_mesh(single_slice, cmap=cmap)
    p.show()



.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_004.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 62-64

Adding slicing planes uniformly across an axial direction can also be
automated with the :func:`pyvista.DataSetFilters.slice_along_axis` filter:

.. GENERATED FROM PYTHON SOURCE LINES 64-70

.. code-block:: default


    slices = mesh.slice_along_axis(n=7, axis="y")

    slices.plot(cmap=cmap)





.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_005.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 71-81

Slice Along Line
++++++++++++++++

We can also slice a dataset along a :func:`pyvista.Spline` or
:func:`pyvista.Line` using the :func:`DataSetFilters.slice_along_line` filter.

First, define a line source through the dataset of interest. Please note
that this type of slicing is computationally expensive and might take a while
if there are a lot of points in the line - try to keep the resolution of
the line low.

.. GENERATED FROM PYTHON SOURCE LINES 81-99

.. code-block:: default


    model = examples.load_channels()


    def path(y):
        """Equation: x = a(y-h)^2 + k"""
        a = 110.0 / 160.0**2
        x = a * y**2 + 0.0
        return x, y


    x, y = path(np.arange(model.bounds[2], model.bounds[3], 15.0))
    zo = np.linspace(9.0, 11.0, num=len(y))
    points = np.c_[x, y, zo]
    spline = pv.Spline(points, 15)
    spline







.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
    <table>
    <tr><th>PolyData</th><th>Information</th></tr>
    <tr><td>N Cells</td><td>1</td></tr>
    <tr><td>N Points</td><td>15</td></tr>
    <tr><td>X Bounds</td><td>0.000e+00, 2.475e+02</td></tr>
    <tr><td>Y Bounds</td><td>0.000e+00, 2.400e+02</td></tr>
    <tr><td>Z Bounds</td><td>9.000e+00, 1.100e+01</td></tr>
    <tr><td>N Arrays</td><td>1</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
    <tr><td>arc_length</td><td>Points</td><td>float32</td><td>1</td><td>0.000e+00</td><td>3.605e+02</td></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 100-101

Then run the filter

.. GENERATED FROM PYTHON SOURCE LINES 101-104

.. code-block:: default

    slc = model.slice_along_line(spline)
    slc






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
    <table>
    <tr><th>PolyData</th><th>Information</th></tr>
    <tr><td>N Cells</td><td>49100</td></tr>
    <tr><td>N Points</td><td>49692</td></tr>
    <tr><td>X Bounds</td><td>0.000e+00, 2.500e+02</td></tr>
    <tr><td>Y Bounds</td><td>0.000e+00, 2.415e+02</td></tr>
    <tr><td>Z Bounds</td><td>0.000e+00, 1.000e+02</td></tr>
    <tr><td>N Arrays</td><td>1</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
    <tr><td><b>facies</b></td><td>Cells</td><td>int64</td><td>1</td><td>0.000e+00</td><td>4.000e+00</td></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 105-112

.. code-block:: default


    p = pv.Plotter()
    p.add_mesh(slc, cmap=cmap)
    p.add_mesh(model.outline())
    p.show(cpos=[1, -1, 1])





.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_006.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 113-117

Multiple Slices in Vector Direction
+++++++++++++++++++++++++++++++++++

Slice a mesh along a vector direction perpendicularly.

.. GENERATED FROM PYTHON SOURCE LINES 117-138

.. code-block:: default


    mesh = examples.download_brain()

    # Create vector
    vec = np.random.rand(3)
    # Normalize the vector
    normal = vec / np.linalg.norm(vec)

    # Make points along that vector for the extent of your slices
    a = mesh.center + normal * mesh.length / 3.0
    b = mesh.center - normal * mesh.length / 3.0

    # Define the line/points for the slices
    n_slices = 5
    line = pv.Line(a, b, n_slices)

    # Generate all of the slices
    slices = pv.MultiBlock()
    for point in line.points:
        slices.append(mesh.slice(normal=normal, origin=point))








.. GENERATED FROM PYTHON SOURCE LINES 139-147

.. code-block:: default


    p = pv.Plotter()
    p.add_mesh(mesh.outline(), color="k")
    p.add_mesh(slices, opacity=0.75)
    p.add_mesh(line, color="red", line_width=5)
    p.show()





.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_007.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 148-157

Slice At Different Bearings
+++++++++++++++++++++++++++

From `pyvista-support#23 <https://github.com/pyvista/pyvista-support/issues/23>`_

An example of how to get many slices at different bearings all centered
around a user-chosen location.

Create a point to orient slices around

.. GENERATED FROM PYTHON SOURCE LINES 157-160

.. code-block:: default

    ranges = np.array(model.bounds).reshape(-1, 2).ptp(axis=1)
    point = np.array(model.center) - ranges * 0.25








.. GENERATED FROM PYTHON SOURCE LINES 161-163

Now generate a few normal vectors to rotate a slice around the z-axis.
Use equation for circle since its about the Z-axis.

.. GENERATED FROM PYTHON SOURCE LINES 163-172

.. code-block:: default

    increment = np.pi / 6.0
    # use a container to hold all the slices
    slices = pv.MultiBlock()  # treat like a dictionary/list
    for theta in np.arange(0, np.pi, increment):
        normal = np.array([np.cos(theta), np.sin(theta), 0.0]).dot(np.pi / 2.0)
        name = f'Bearing: {np.rad2deg(theta):.2f}'
        slices[name] = model.slice(origin=point, normal=normal)
    slices






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Information</th><th>Blocks</th></tr><tr><td>
    <table>
    <tr><th>MultiBlock</th><th>Values</th></tr>
    <tr><td>N Blocks</td><td>6</td></tr>
    <tr><td>X Bounds</td><td>0.000, 250.000</td></tr>
    <tr><td>Y Bounds</td><td>0.000, 250.000</td></tr>
    <tr><td>Z Bounds</td><td>0.000, 100.000</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Index</th><th>Name</th><th>Type</th></tr>
    <tr><th>0</th><th>Bearing: 0.00</th><th>PolyData</th></tr>
    <tr><th>1</th><th>Bearing: 30.00</th><th>PolyData</th></tr>
    <tr><th>2</th><th>Bearing: 60.00</th><th>PolyData</th></tr>
    <tr><th>3</th><th>Bearing: 90.00</th><th>PolyData</th></tr>
    <tr><th>4</th><th>Bearing: 120.00</th><th>PolyData</th></tr>
    <tr><th>5</th><th>Bearing: 150.00</th><th>PolyData</th></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 173-174

And now display it!

.. GENERATED FROM PYTHON SOURCE LINES 174-178

.. code-block:: default

    p = pv.Plotter()
    p.add_mesh(slices, cmap=cmap)
    p.add_mesh(model.outline())
    p.show()



.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_008.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_008.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  23.130 seconds)


.. _sphx_glr_download_examples_01-filter_slicing.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: slicing.py <slicing.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: slicing.ipynb <slicing.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
