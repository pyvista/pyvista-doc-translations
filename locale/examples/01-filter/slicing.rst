
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/01-filter/slicing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_01-filter_slicing.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_01-filter_slicing.py:


.. _slice_example:

Slicing
~~~~~~~

Extract thin planar slices from a volume.

.. GENERATED FROM PYTHON SOURCE LINES 9-15

.. code-block:: default

    import matplotlib.pyplot as plt
    import numpy as np

    import pyvista as pv
    from pyvista import examples








.. GENERATED FROM PYTHON SOURCE LINES 17-26

PyVista meshes have several slicing filters bound directly to all datasets.
These filters allow you to slice through a volumetric dataset to extract and
view sections through the volume of data.

One of the most common slicing filters used in PyVista is the
:func:`pyvista.DataSetFilters.slice_orthogonal` filter which creates three
orthogonal slices through the dataset parallel to the three Cartesian planes.
For example, let's slice through the sample geostatistical training image
volume. First, load up the volume and preview it:

.. GENERATED FROM PYTHON SOURCE LINES 26-33

.. code-block:: default


    mesh = examples.load_channels()
    # define a categorical colormap
    cmap = plt.cm.get_cmap("viridis", 4)

    mesh.plot(cmap=cmap)




.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_001.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/work/pyvista-doc-translations/pyvista-doc-translations/pyvista/examples/01-filter/slicing.py:29: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed two minor releases later. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap(obj)`` instead.
      cmap = plt.cm.get_cmap("viridis", 4)




.. GENERATED FROM PYTHON SOURCE LINES 34-37

Note that this dataset is a 3D volume and there might be regions within this
volume that we would like to inspect. We can create slices through the mesh
to gain further insight about the internals of the volume.

.. GENERATED FROM PYTHON SOURCE LINES 37-43

.. code-block:: default


    slices = mesh.slice_orthogonal()

    slices.plot(cmap=cmap)





.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_002.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 44-45

The orthogonal slices can be easily translated throughout the volume:

.. GENERATED FROM PYTHON SOURCE LINES 45-48

.. code-block:: default


    slices = mesh.slice_orthogonal(x=20, y=20, z=30)
    slices.plot(cmap=cmap)



.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_003.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 49-52

We can also add just a single slice of the volume by specifying the origin
and normal of the slicing plane with the :func:`pyvista.DataSetFilters.slice`
filter:

.. GENERATED FROM PYTHON SOURCE LINES 52-60

.. code-block:: default


    # Single slice - origin defaults to the center of the mesh
    single_slice = mesh.slice(normal=[1, 1, 0])

    p = pv.Plotter()
    p.add_mesh(mesh.outline(), color="k")
    p.add_mesh(single_slice, cmap=cmap)
    p.show()



.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_004.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 61-63

Adding slicing planes uniformly across an axial direction can also be
automated with the :func:`pyvista.DataSetFilters.slice_along_axis` filter:

.. GENERATED FROM PYTHON SOURCE LINES 63-69

.. code-block:: default


    slices = mesh.slice_along_axis(n=7, axis="y")

    slices.plot(cmap=cmap)





.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_005.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 70-80

Slice Along Line
++++++++++++++++

We can also slice a dataset along a :func:`pyvista.Spline` or
:func:`pyvista.Line` using the :func:`pyvista.DataSetFilters.slice_along_line` filter.

First, define a line source through the dataset of interest. Please note
that this type of slicing is computationally expensive and might take a while
if there are a lot of points in the line - try to keep the resolution of
the line low.

.. GENERATED FROM PYTHON SOURCE LINES 80-98

.. code-block:: default


    model = examples.load_channels()


    def path(y):
        """Equation: x = a(y-h)^2 + k"""
        a = 110.0 / 160.0**2
        x = a * y**2 + 0.0
        return x, y


    x, y = path(np.arange(model.bounds[2], model.bounds[3], 15.0))
    zo = np.linspace(9.0, 11.0, num=len(y))
    points = np.c_[x, y, zo]
    spline = pv.Spline(points, 15)
    spline







.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
    <table>
    <tr><th>PolyData</th><th>Information</th></tr>
    <tr><td>N Cells</td><td>1</td></tr>
    <tr><td>N Points</td><td>15</td></tr>
    <tr><td>N Strips</td><td>0</td></tr>
    <tr><td>X Bounds</td><td>0.000e+00, 2.475e+02</td></tr>
    <tr><td>Y Bounds</td><td>0.000e+00, 2.400e+02</td></tr>
    <tr><td>Z Bounds</td><td>9.000e+00, 1.100e+01</td></tr>
    <tr><td>N Arrays</td><td>1</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
    <tr><td>arc_length</td><td>Points</td><td>float32</td><td>1</td><td>0.000e+00</td><td>3.605e+02</td></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 99-100

Then run the filter

.. GENERATED FROM PYTHON SOURCE LINES 100-103

.. code-block:: default

    slc = model.slice_along_line(spline)
    slc






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
    <table>
    <tr><th>PolyData</th><th>Information</th></tr>
    <tr><td>N Cells</td><td>49100</td></tr>
    <tr><td>N Points</td><td>49692</td></tr>
    <tr><td>N Strips</td><td>0</td></tr>
    <tr><td>X Bounds</td><td>0.000e+00, 2.500e+02</td></tr>
    <tr><td>Y Bounds</td><td>0.000e+00, 2.415e+02</td></tr>
    <tr><td>Z Bounds</td><td>0.000e+00, 1.000e+02</td></tr>
    <tr><td>N Arrays</td><td>1</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
    <tr><td><b>facies</b></td><td>Cells</td><td>int64</td><td>1</td><td>0.000e+00</td><td>4.000e+00</td></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 104-111

.. code-block:: default


    p = pv.Plotter()
    p.add_mesh(slc, cmap=cmap)
    p.add_mesh(model.outline())
    p.show(cpos=[1, -1, 1])





.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_006.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 112-116

Multiple Slices in Vector Direction
+++++++++++++++++++++++++++++++++++

Slice a mesh along a vector direction perpendicularly.

.. GENERATED FROM PYTHON SOURCE LINES 116-137

.. code-block:: default


    mesh = examples.download_brain()

    # Create vector
    vec = np.array([1.0, 2.0, 1.0])
    # Normalize the vector
    normal = vec / np.linalg.norm(vec)

    # Make points along that vector for the extent of your slices
    a = mesh.center + normal * mesh.length / 3.0
    b = mesh.center - normal * mesh.length / 3.0

    # Define the line/points for the slices
    n_slices = 5
    line = pv.Line(a, b, n_slices)

    # Generate all of the slices
    slices = pv.MultiBlock()
    for point in line.points:
        slices.append(mesh.slice(normal=normal, origin=point))








.. GENERATED FROM PYTHON SOURCE LINES 138-146

.. code-block:: default


    p = pv.Plotter()
    p.add_mesh(mesh.outline(), color="k")
    p.add_mesh(slices, opacity=0.75)
    p.add_mesh(line, color="red", line_width=5)
    p.show()





.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_007.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 147-156

Slice At Different Bearings
+++++++++++++++++++++++++++

From `pyvista-support#23 <https://github.com/pyvista/pyvista-support/issues/23>`_

An example of how to get many slices at different bearings all centered
around a user-chosen location.

Create a point to orient slices around

.. GENERATED FROM PYTHON SOURCE LINES 156-159

.. code-block:: default

    ranges = np.array(model.bounds).reshape(-1, 2).ptp(axis=1)
    point = np.array(model.center) - ranges * 0.25








.. GENERATED FROM PYTHON SOURCE LINES 160-162

Now generate a few normal vectors to rotate a slice around the z-axis.
Use equation for circle since its about the Z-axis.

.. GENERATED FROM PYTHON SOURCE LINES 162-171

.. code-block:: default

    increment = np.pi / 6.0
    # use a container to hold all the slices
    slices = pv.MultiBlock()  # treat like a dictionary/list
    for theta in np.arange(0, np.pi, increment):
        normal = np.array([np.cos(theta), np.sin(theta), 0.0]).dot(np.pi / 2.0)
        name = f'Bearing: {np.rad2deg(theta):.2f}'
        slices[name] = model.slice(origin=point, normal=normal)
    slices






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Information</th><th>Blocks</th></tr><tr><td>
    <table>
    <tr><th>MultiBlock</th><th>Values</th></tr>
    <tr><td>N Blocks</td><td>6</td></tr>
    <tr><td>X Bounds</td><td>0.000, 250.000</td></tr>
    <tr><td>Y Bounds</td><td>0.000, 250.000</td></tr>
    <tr><td>Z Bounds</td><td>0.000, 100.000</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Index</th><th>Name</th><th>Type</th></tr>
    <tr><th>0</th><th>Bearing: 0.00</th><th>PolyData</th></tr>
    <tr><th>1</th><th>Bearing: 30.00</th><th>PolyData</th></tr>
    <tr><th>2</th><th>Bearing: 60.00</th><th>PolyData</th></tr>
    <tr><th>3</th><th>Bearing: 90.00</th><th>PolyData</th></tr>
    <tr><th>4</th><th>Bearing: 120.00</th><th>PolyData</th></tr>
    <tr><th>5</th><th>Bearing: 150.00</th><th>PolyData</th></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 172-173

And now display it.

.. GENERATED FROM PYTHON SOURCE LINES 173-177

.. code-block:: default

    p = pv.Plotter()
    p.add_mesh(slices, cmap=cmap)
    p.add_mesh(model.outline())
    p.show()



.. image-sg:: /examples/01-filter/images/sphx_glr_slicing_008.png
   :alt: slicing
   :srcset: /examples/01-filter/images/sphx_glr_slicing_008.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  20.153 seconds)


.. _sphx_glr_download_examples_01-filter_slicing.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: slicing.py <slicing.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: slicing.ipynb <slicing.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
