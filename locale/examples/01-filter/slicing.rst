
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/01-filter/slicing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_01-filter_slicing.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_01-filter_slicing.py:


Slicing
~~~~~~~

Extract thin planar slices from a volume

.. GENERATED FROM PYTHON SOURCE LINES 7-13

.. code-block:: default

    # sphinx_gallery_thumbnail_number = 2
    import pyvista as pv
    from pyvista import examples
    import matplotlib.pyplot as plt
    import numpy as np








.. GENERATED FROM PYTHON SOURCE LINES 14-23

PyVista meshes have several slicing filters bound directly to all datasets.
These filters allow you to slice through a volumetric dataset to extract and
view sections through the volume of data.

One of the most common slicing filters used in PyVista is the
:func:`pyvista.DataSetFilters.slice_orthogonal` filter which creates three
orthogonal slices through the dataset parallel to the three Cartesian planes.
For example, let's slice through the sample geostatistical training image
volume. First, load up the volume and preview it:

.. GENERATED FROM PYTHON SOURCE LINES 23-31

.. code-block:: default


    mesh = examples.load_channels()
    # define a categorical colormap
    cmap = plt.cm.get_cmap("viridis", 4)


    mesh.plot(cmap=cmap)




.. image:: /examples/01-filter/images/sphx_glr_slicing_001.png
    :alt: slicing
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [(534.8076211353316, 534.8076211353316, 459.80762113533166),
     (125.0, 125.0, 50.0),
     (0.0, 0.0, 1.0)]



.. GENERATED FROM PYTHON SOURCE LINES 32-35

Note that this dataset is a 3D volume and there might be regions within this
volume that we would like to inspect. We can create slices through the mesh
to gain further insight about the internals of the volume.

.. GENERATED FROM PYTHON SOURCE LINES 35-41

.. code-block:: default


    slices = mesh.slice_orthogonal()

    slices.plot(cmap=cmap)





.. image:: /examples/01-filter/images/sphx_glr_slicing_002.png
    :alt: slicing
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [(534.8076211353316, 534.8076211353316, 459.80762113533166),
     (125.0, 125.0, 50.0),
     (0.0, 0.0, 1.0)]



.. GENERATED FROM PYTHON SOURCE LINES 42-43

The orthogonal slices can be easily translated throughout the volume:

.. GENERATED FROM PYTHON SOURCE LINES 43-46

.. code-block:: default


    slices = mesh.slice_orthogonal(x=20, y=20, z=30)
    slices.plot(cmap=cmap)



.. image:: /examples/01-filter/images/sphx_glr_slicing_003.png
    :alt: slicing
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [(534.8076211353316, 534.8076211353316, 459.80762113533166),
     (125.0, 125.0, 50.0),
     (0.0, 0.0, 1.0)]



.. GENERATED FROM PYTHON SOURCE LINES 47-50

We can also add just a single slice of the volume by specifying the origin
and normal of the slicing plane with the :func:`pyvista.DataSetFilters.slice`
filter:

.. GENERATED FROM PYTHON SOURCE LINES 50-58

.. code-block:: default


    # Single slice - origin defaults to the center of the mesh
    single_slice = mesh.slice(normal=[1, 1, 0])

    p = pv.Plotter()
    p.add_mesh(mesh.outline(), color="k")
    p.add_mesh(single_slice, cmap=cmap)
    p.show()



.. image:: /examples/01-filter/images/sphx_glr_slicing_004.png
    :alt: slicing
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [(534.8076211353316, 534.8076211353316, 459.80762113533166),
     (125.0, 125.0, 50.0),
     (0.0, 0.0, 1.0)]



.. GENERATED FROM PYTHON SOURCE LINES 59-61

Adding slicing planes uniformly across an axial direction can also be
automated with the :func:`pyvista.DataSetFilters.slice_along_axis` filter:

.. GENERATED FROM PYTHON SOURCE LINES 61-67

.. code-block:: default


    slices = mesh.slice_along_axis(n=7, axis="y")

    slices.plot(cmap=cmap)





.. image:: /examples/01-filter/images/sphx_glr_slicing_005.png
    :alt: slicing
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [(531.0336740029763, 531.0336740029763, 456.0336740029763),
     (125.0, 125.0, 50.0),
     (0.0, 0.0, 1.0)]



.. GENERATED FROM PYTHON SOURCE LINES 68-78

Slice Along Line
++++++++++++++++

We can also slice a dataset along a :func:`pyvista.Spline` or
:func:`pyvista.Line` using the :func:`DataSetFilters.slice_along_line` filter.

First, define a line source through the dataset of interest. Please note
that this type of slicing is computationally expensive and might take a while
if there are a lot of points in the line - try to keep the resolution of
the line low.

.. GENERATED FROM PYTHON SOURCE LINES 78-96

.. code-block:: default


    model = examples.load_channels()


    def path(y):
        """Equation: x = a(y-h)^2 + k"""
        a = 110.0 / 160.0 ** 2
        x = a * y ** 2 + 0.0
        return x, y


    x, y = path(np.arange(model.bounds[2], model.bounds[3], 15.0))
    zo = np.linspace(9.0, 11.0, num=len(y))
    points = np.c_[x, y, zo]
    spline = pv.Spline(points, 15)
    spline







.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
    <table>
    <tr><th>PolyData</th><th>Information</th></tr>
    <tr><td>N Cells</td><td>1</td></tr>
    <tr><td>N Points</td><td>15</td></tr>
    <tr><td>X Bounds</td><td>0.000e+00, 2.475e+02</td></tr>
    <tr><td>Y Bounds</td><td>0.000e+00, 2.400e+02</td></tr>
    <tr><td>Z Bounds</td><td>9.000e+00, 1.100e+01</td></tr>
    <tr><td>N Arrays</td><td>1</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
    <tr><td><b>arc_length</b></td><td>Points</td><td>float32</td><td>1</td><td>0.000e+00</td><td>3.605e+02</td></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 97-98

Then run the filter

.. GENERATED FROM PYTHON SOURCE LINES 98-101

.. code-block:: default

    slc = model.slice_along_line(spline)
    slc






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
    <table>
    <tr><th>PolyData</th><th>Information</th></tr>
    <tr><td>N Cells</td><td>49100</td></tr>
    <tr><td>N Points</td><td>49692</td></tr>
    <tr><td>X Bounds</td><td>0.000e+00, 2.500e+02</td></tr>
    <tr><td>Y Bounds</td><td>0.000e+00, 2.415e+02</td></tr>
    <tr><td>Z Bounds</td><td>0.000e+00, 1.000e+02</td></tr>
    <tr><td>N Arrays</td><td>1</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
    <tr><td><b>facies</b></td><td>Cells</td><td>int64</td><td>1</td><td>0.000e+00</td><td>4.000e+00</td></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 102-109

.. code-block:: default


    p = pv.Plotter()
    p.add_mesh(slc, cmap=cmap)
    p.add_mesh(model.outline())
    p.show(cpos=[1, -1, 1])





.. image:: /examples/01-filter/images/sphx_glr_slicing_006.png
    :alt: slicing
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [(534.8076211353316, -284.80762113533166, 459.80762113533166),
     (125.0, 125.0, 50.0),
     (0.0, 0.0, 1.0)]



.. GENERATED FROM PYTHON SOURCE LINES 110-114

Multiple Slices in Vector Direction
+++++++++++++++++++++++++++++++++++

Slice a mesh along a vector direction perpendicularly.

.. GENERATED FROM PYTHON SOURCE LINES 114-135

.. code-block:: default


    mesh = examples.download_brain()

    # Create vector
    vec = np.random.rand(3)
    # Normalize the vector
    normal = vec / np.linalg.norm(vec)

    # Make points along that vector for the extent of your slices
    a = mesh.center + normal * mesh.length / 3.0
    b = mesh.center - normal * mesh.length / 3.0

    # Define the line/points for the slices
    n_slices = 5
    line = pv.Line(a, b, n_slices)

    # Generate all of the slices
    slices = pv.MultiBlock()
    for point in line.points:
        slices.append(mesh.slice(normal=normal, origin=point))








.. GENERATED FROM PYTHON SOURCE LINES 136-145

.. code-block:: default


    p = pv.Plotter()
    p.add_mesh(mesh.outline(), color="k")
    p.add_mesh(slices, opacity=0.75)
    p.add_mesh(line, color="red", line_width=5)
    p.show()






.. image:: /examples/01-filter/images/sphx_glr_slicing_007.png
    :alt: slicing
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [(462.3615871740787, 480.3615871740787, 462.3615871740787),
     (90.0, 108.0, 90.0),
     (0.0, 0.0, 1.0)]



.. GENERATED FROM PYTHON SOURCE LINES 146-155

Slice At Different Bearings
+++++++++++++++++++++++++++

From `pyvista-support#23 <https://github.com/pyvista/pyvista-support/issues/23>`_

An example of how to get many slices at different bearings all centered
around a user-chosen location.

Create a point to orient slices around

.. GENERATED FROM PYTHON SOURCE LINES 155-158

.. code-block:: default

    ranges = np.array(model.bounds).reshape(-1, 2).ptp(axis=1)
    point = np.array(model.center) - ranges*0.25








.. GENERATED FROM PYTHON SOURCE LINES 159-161

Now generate a few normal vectors to rotate a slice around the z-axis.
Use equation for circle since its about the Z-axis.

.. GENERATED FROM PYTHON SOURCE LINES 161-170

.. code-block:: default

    increment = np.pi/6.
    # use a container to hold all the slices
    slices = pv.MultiBlock() # treat like a dictionary/list
    for theta in np.arange(0, np.pi, increment):
        normal = np.array([np.cos(theta), np.sin(theta), 0.0]).dot(np.pi/2.)
        name = f'Bearing: {np.rad2deg(theta):.2f}'
        slices[name] = model.slice(origin=point, normal=normal)
    slices






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Information</th><th>Blocks</th></tr><tr><td>
    <table>
    <tr><th>MultiBlock</th><th>Values</th></tr>
    <tr><td>N Blocks</td><td>6</td></tr>
    <tr><td>X Bounds</td><td>0.000, 250.000</td></tr>
    <tr><td>Y Bounds</td><td>0.000, 250.000</td></tr>
    <tr><td>Z Bounds</td><td>0.000, 100.000</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Index</th><th>Name</th><th>Type</th></tr>
    <tr><th>0</th><th>Bearing: 0.00</th><th>PolyData</th></tr>
    <tr><th>1</th><th>Bearing: 30.00</th><th>PolyData</th></tr>
    <tr><th>2</th><th>Bearing: 60.00</th><th>PolyData</th></tr>
    <tr><th>3</th><th>Bearing: 90.00</th><th>PolyData</th></tr>
    <tr><th>4</th><th>Bearing: 120.00</th><th>PolyData</th></tr>
    <tr><th>5</th><th>Bearing: 150.00</th><th>PolyData</th></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 171-172

And now display it!

.. GENERATED FROM PYTHON SOURCE LINES 172-176

.. code-block:: default

    p = pv.Plotter()
    p.add_mesh(slices, cmap=cmap)
    p.add_mesh(model.outline())
    p.show()



.. image:: /examples/01-filter/images/sphx_glr_slicing_008.png
    :alt: slicing
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [(534.8076211353316, 534.8076211353316, 459.80762113533166),
     (125.0, 125.0, 50.0),
     (0.0, 0.0, 1.0)]




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  35.039 seconds)


.. _sphx_glr_download_examples_01-filter_slicing.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: slicing.py <slicing.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: slicing.ipynb <slicing.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
