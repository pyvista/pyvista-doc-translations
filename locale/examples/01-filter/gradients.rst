
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/01-filter/gradients.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_01-filter_gradients.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_01-filter_gradients.py:


.. _gradients_example:

Compute Gradients of a Field
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Estimate the gradient of a scalar or vector field in a data set.

The ordering for the output gradient tuple will be
{du/dx, du/dy, du/dz, dv/dx, dv/dy, dv/dz, dw/dx, dw/dy, dw/dz} for
an input array {u, v, w}.

Showing the :func:`pyvista.DataSetFilters.compute_derivative` filter.

.. GENERATED FROM PYTHON SOURCE LINES 15-25

.. code-block:: default


    import numpy as np

    # sphinx_gallery_thumbnail_number = 1
    import pyvista as pv
    from pyvista import examples

    # A vtkStructuredGrid - but could be any mesh type
    mesh = examples.download_carotid()
    mesh





.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
    <table>
    <tr><th>UniformGrid</th><th>Information</th></tr>
    <tr><td>N Cells</td><td>158400</td></tr>
    <tr><td>N Points</td><td>167580</td></tr>
    <tr><td>X Bounds</td><td>1.000e+02, 1.750e+02</td></tr>
    <tr><td>Y Bounds</td><td>8.000e+01, 1.280e+02</td></tr>
    <tr><td>Z Bounds</td><td>1.000e+00, 4.500e+01</td></tr>
    <tr><td>Dimensions</td><td>76, 49, 45</td></tr>
    <tr><td>Spacing</td><td>1.000e+00, 1.000e+00, 1.000e+00</td></tr>
    <tr><td>N Arrays</td><td>2</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
    <tr><td><b>scalars</b></td><td>Points</td><td>float32</td><td>1</td><td>0.000e+00</td><td>5.800e+02</td></tr>
    <tr><td>vectors</td><td>Points</td><td>float32</td><td>3</td><td>-2.263e+01</td><td>1.662e+01</td></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 26-29

Now compute the gradients of the ``vectors`` vector field in the point data
of that mesh. This is as simple as calling
:func:`pyvista.DataSetFilters.compute_derivative`.

.. GENERATED FROM PYTHON SOURCE LINES 29-32

.. code-block:: default

    mesh_g = mesh.compute_derivative(scalars="vectors")
    mesh_g["gradient"]





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    array([[ 7.2189998e-03,  7.6569999e-03,  3.8799997e-03, ...,
            -7.3850001e-03,  1.0060001e-03, -2.1000043e-05],
           [ 4.2885002e-03,  9.3000010e-04, -6.5520001e-03, ...,
            -6.1399997e-03,  3.6770001e-03,  1.1730000e-02],
           [ 5.4014996e-03,  1.2539998e-03, -4.6510003e-03, ...,
             3.4900010e-04,  8.0140000e-03,  8.1439996e-03],
           ...,
           [-6.3999998e-04, -2.6340000e-03,  6.1740000e-03, ...,
            -4.3205000e-03, -1.2229999e-03, -1.8960000e-03],
           [-1.5900000e-03, -3.4460002e-03,  4.1279998e-03, ...,
            -2.9000000e-03, -5.9960000e-03, -5.8140000e-03],
           [-9.1199996e-04, -4.0670000e-03, -1.5819999e-03, ...,
            -2.4759998e-03, -8.5290000e-03, -5.3939996e-03]], dtype=float32)



.. GENERATED FROM PYTHON SOURCE LINES 33-36

.. note:: You can also use :func:`pyvista.DataSetFilters.compute_derivative` for
  computing other derivative based quantities, such as divergence, vorticity,
  and Q-criterion. See function documentation for options.

.. GENERATED FROM PYTHON SOURCE LINES 38-40

``mesh_g["gradient"]`` is an ``N`` by 9 NumPy array of the gradients, so we
could make a dictionary of NumPy arrays of the gradients like:

.. GENERATED FROM PYTHON SOURCE LINES 40-50

.. code-block:: default


    def gradients_to_dict(arr):
        """A helper method to label the gradients into a dictionary."""
        keys = np.array(["du/dx", "du/dy", "du/dz", "dv/dx", "dv/dy", "dv/dz", "dw/dx", "dw/dy", "dw/dz"])
        keys = keys.reshape((3,3))[:,:arr.shape[1]].ravel()
        return dict(zip(keys, mesh_g["gradient"].T))

    gradients = gradients_to_dict(mesh_g["gradient"])
    gradients





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    {'du/dx': array([ 0.007219 ,  0.0042885,  0.0054015, ..., -0.00064  , -0.00159  ,
           -0.000912 ], dtype=float32), 'du/dy': array([ 0.007657,  0.00093 ,  0.001254, ..., -0.002634, -0.003446,
           -0.004067], dtype=float32), 'du/dz': array([ 0.00388 , -0.006552, -0.004651, ...,  0.006174,  0.004128,
           -0.001582], dtype=float32), 'dv/dx': array([-7.5999997e-04, -1.0585000e-03, -2.9600000e-03, ...,
           -1.9554999e-03,  9.9999888e-06,  2.6600000e-03], dtype=float32), 'dv/dy': array([ 0.000226, -0.00503 , -0.003388, ..., -0.0059  , -0.008274,
           -0.000512], dtype=float32), 'dv/dz': array([-0.006821, -0.000382,  0.006909, ..., -0.001991, -0.003061,
           -0.00189 ], dtype=float32), 'dw/dx': array([-0.007385 , -0.00614  ,  0.000349 , ..., -0.0043205, -0.0029   ,
           -0.002476 ], dtype=float32), 'dw/dy': array([ 0.001006,  0.003677,  0.008014, ..., -0.001223, -0.005996,
           -0.008529], dtype=float32), 'dw/dz': array([-2.1000043e-05,  1.1730000e-02,  8.1439996e-03, ...,
           -1.8960000e-03, -5.8140000e-03, -5.3939996e-03], dtype=float32)}



.. GENERATED FROM PYTHON SOURCE LINES 51-53

And we can add all of those components as individual arrays back to the mesh
by:

.. GENERATED FROM PYTHON SOURCE LINES 53-56

.. code-block:: default

    mesh_g.point_data.update(gradients)
    mesh_g






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table><tr><th>Header</th><th>Data Arrays</th></tr><tr><td>
    <table>
    <tr><th>UniformGrid</th><th>Information</th></tr>
    <tr><td>N Cells</td><td>158400</td></tr>
    <tr><td>N Points</td><td>167580</td></tr>
    <tr><td>X Bounds</td><td>1.000e+02, 1.750e+02</td></tr>
    <tr><td>Y Bounds</td><td>8.000e+01, 1.280e+02</td></tr>
    <tr><td>Z Bounds</td><td>1.000e+00, 4.500e+01</td></tr>
    <tr><td>Dimensions</td><td>76, 49, 45</td></tr>
    <tr><td>Spacing</td><td>1.000e+00, 1.000e+00, 1.000e+00</td></tr>
    <tr><td>N Arrays</td><td>12</td></tr>
    </table>

    </td><td>
    <table>
    <tr><th>Name</th><th>Field</th><th>Type</th><th>N Comp</th><th>Min</th><th>Max</th></tr>
    <tr><td>scalars</td><td>Points</td><td>float32</td><td>1</td><td>0.000e+00</td><td>5.800e+02</td></tr>
    <tr><td>vectors</td><td>Points</td><td>float32</td><td>3</td><td>-2.263e+01</td><td>1.662e+01</td></tr>
    <tr><td>gradient</td><td>Points</td><td>float32</td><td>9</td><td>-1.585e+01</td><td>1.536e+01</td></tr>
    <tr><td>du/dx</td><td>Points</td><td>float32</td><td>1</td><td>-8.293e+00</td><td>8.336e+00</td></tr>
    <tr><td>du/dy</td><td>Points</td><td>float32</td><td>1</td><td>-1.084e+01</td><td>8.334e+00</td></tr>
    <tr><td>du/dz</td><td>Points</td><td>float32</td><td>1</td><td>-8.300e+00</td><td>8.317e+00</td></tr>
    <tr><td>dv/dx</td><td>Points</td><td>float32</td><td>1</td><td>-1.133e+01</td><td>1.536e+01</td></tr>
    <tr><td>dv/dy</td><td>Points</td><td>float32</td><td>1</td><td>-1.585e+01</td><td>1.170e+01</td></tr>
    <tr><td>dv/dz</td><td>Points</td><td>float32</td><td>1</td><td>-1.131e+01</td><td>7.459e+00</td></tr>
    <tr><td>dw/dx</td><td>Points</td><td>float32</td><td>1</td><td>-8.738e+00</td><td>1.212e+01</td></tr>
    <tr><td>dw/dy</td><td>Points</td><td>float32</td><td>1</td><td>-8.734e+00</td><td>8.740e+00</td></tr>
    <tr><td><b>dw/dz</b></td><td>Points</td><td>float32</td><td>1</td><td>-1.124e+01</td><td>8.728e+00</td></tr>
    </table>

    </td></tr> </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 57-73

.. code-block:: default


    keys = np.array(list(gradients.keys())).reshape(3,3)

    p = pv.Plotter(shape=keys.shape)
    for i in range(keys.shape[0]):
        for j in range(keys.shape[1]):
            name = keys[i,j]
            p.subplot(i,j)
            p.add_mesh(mesh_g.contour(scalars=name), scalars=name, opacity=0.75)
            p.add_mesh(mesh_g.outline(), color="k")
    p.link_views()
    p.view_isometric()
    p.show()






.. image-sg:: /examples/01-filter/images/sphx_glr_gradients_001.png
   :alt: gradients
   :srcset: /examples/01-filter/images/sphx_glr_gradients_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 74-76

And there you have it, the gradients for a vector field! We could also do
this for a scalar  field like for the ``scalars`` field in the given dataset.

.. GENERATED FROM PYTHON SOURCE LINES 76-81

.. code-block:: default

    mesh_g = mesh.compute_derivative(scalars="scalars")

    gradients = gradients_to_dict(mesh_g["gradient"])
    gradients





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    {'du/dx': array([-7. , -7. , -4. , ..., -0.5, -1.5, -2. ], dtype=float32), 'du/dy': array([ 0.,  5., 12., ..., -3., -1., -3.], dtype=float32), 'du/dz': array([-13.,  -8.,  -3., ...,   4.,   4.,   1.], dtype=float32)}



.. GENERATED FROM PYTHON SOURCE LINES 82-99

.. code-block:: default


    mesh_g.point_data.update(gradients)

    keys = np.array(list(gradients.keys())).reshape(1,3)

    p = pv.Plotter(shape=keys.shape)

    for i in range(keys.shape[0]):
        for j in range(keys.shape[1]):
            name = keys[i,j]
            p.subplot(i,j)
            p.add_mesh(mesh_g.contour(scalars=name), scalars=name, opacity=0.75)
            p.add_mesh(mesh_g.outline(), color="k")
    p.link_views()
    p.view_isometric()
    p.show()




.. image-sg:: /examples/01-filter/images/sphx_glr_gradients_002.png
   :alt: gradients
   :srcset: /examples/01-filter/images/sphx_glr_gradients_002.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  2.055 seconds)


.. _sphx_glr_download_examples_01-filter_gradients.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: gradients.py <gradients.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: gradients.ipynb <gradients.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
