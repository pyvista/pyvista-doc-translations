# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2025, The PyVista Developers
# This file is distributed under the same license as the PyVista package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Tetsuo Koyama <tkoyama010@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PyVista 0.46.dev0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-19 02:44+0000\n"
"PO-Revision-Date: 2021-05-06 09:39+0000\n"
"Last-Translator: Tetsuo Koyama <tkoyama010@gmail.com>, 2025\n"
"Language-Team: Japanese (https://app.transifex.com/tkoyama010/teams/112279/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../pyvista/doc/source/user-guide/data_model.rst:4
msgid "PyVista Data Model"
msgstr "PyVistaデータモデル"

#: ../../pyvista/doc/source/user-guide/data_model.rst:5
msgid ""
"This section of the user guide explains in detail how to construct meshes "
"from scratch and to utilize the underlying VTK data model but using the "
"PyVista framework. Many of our :ref:`examples` simply load data from files, "
"but don't explain how to construct meshes or place data within datasets."
msgstr ""
"このセクションでは，PyVistaフレームワークを使って，スクラッチからメッシュを作成する方法や，基礎となるVTKデータモデルを利用する方法を詳しく説明します．"
" 私たちの :ref:`examples` "
"の多くは，単にファイルからデータを読み込むだけで，メッシュを構築したり，データセット内にデータを配置する方法を説明していません．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:12
msgid ""
"Though the following documentation section references VTK, it does not "
"require that you have knowledge of VTK. For those who wish to see a detailed"
" comparison to VTK or translate code written for the Python bindings of VTK "
"to PyVista, please see :ref:`vtk_to_pyvista_docs`."
msgstr ""
"以下のドキュメントセクションはVTKを参照していますが，VTKの知識を必要とするものではありません． "
"VTKとの詳細な比較や，VTKのPythonバインディングのために書かれたコードをPyVistaに翻訳したい方は， "
":ref:`vtk_to_pyvista_docs` を参照してください．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:18
msgid "For a more general description of our API, see :ref:`what_is_a_mesh`."
msgstr "APIのより一般的な説明については， :ref:`what_is_a_mesh` をご覧ください．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:22
msgid "The PyVista DataSet"
msgstr "PyVistaデータセット"

#: ../../pyvista/doc/source/user-guide/data_model.rst:23
msgid ""
"To visualize data in VTK or PyVista, two pieces of information are required:"
" the data's geometry, which describes where the data is positioned in space "
"and what its values are, and its topology, which describes how points in the"
" dataset are connected to one another."
msgstr ""
"VTKやPyVistaでデータを可視化するには，2つの情報が必要です．空間内の位置や値を表すデータのジオメトリと，データセット内の点が互いにどのように接続されているかを表すトポロジです．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:28
msgid ""
"At the top level, we have :vtk:`vtkDataObject`, which are just \"blobs\" of "
"data without geometry or topology. These contain arrays of "
":vtk:`vtkFieldData`. Under this are :vtk:`vtkDataSet`, which add geometry "
"and topology to :vtk:`vtkDataObject`. Associated with every point or cell in"
" the dataset is a specific value. Since these values must be positioned and "
"connected in space, they are held in the :vtk:`vtkDataArray` class, which "
"are simply memory buffers on the heap. In PyVista, 99% of the time we "
"interact with :vtk:`vtkDataSet` objects rather than with "
":vtk:`vtkDataObject` objects. PyVista uses the same data types as VTK, but "
"structures them in a more pythonic manner for ease of use."
msgstr ""
"一番上のレベルには :vtk:`vtkDataObject` があります．これはジオメトリやトポロジーを持たない，単なるデータの \"塊\" "
"です．これには :vtk:`vtkFieldData` の配列が含まれます．その下にあるのが :vtk:`vtkDataSet` で，これは "
":vtk:`vtkDataObject` "
"にジオメトリやトポロジを追加するものです．データセット内の全ての点やセルには特定の値が関連付けられている．これらの値は空間に配置され，接続されなければならないので，"
" :vtk:`vtkDataArray` クラスに保持され，これは単なるヒープ上のメモリバッファです．PyVistaでは，99%の場合， "
":vtk:`vtkDataObject` オブジェクトではなく， :vtk:`vtkDataSet` オブジェクトを操作します．PyVista は "
"VTK と同じデータ型を使用しますが，使いやすくするために，よりpythonicな方法で構造化しています．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:39
msgid ""
"If you'd like some background for how VTK structures its data, see "
"`Introduction to VTK in Python by Kitware <https://vimeo.com/32232190>`_, as"
" well as the numerous code examples on `Kitware's GitHub site "
"<https://kitware.github.io/vtk-examples/site/>`_. An excellent introduction "
"to mathematical concepts relevant to 3D modeling in general implemented in "
"VTK is provided by the `Discrete Differential Geometry YouTube Series "
"<https://www.youtube.com/playlist?list=PL9_jI1bdZmz0hIrNCMQW1YmZysAiIYSSS>`_"
" by Prof. Keenan Crane at Carnegie Mellon. The concepts taught here will "
"help improve your understanding of why data sets are structured the way they"
" are in libraries like VTK."
msgstr ""
"VTKがどのようにデータを構成しているかの背景を知りたい方は， `Introduction to VTK in Python by Kitware "
"<https://vimeo.com/32232190>`_ や， `Kitware's GitHub site "
"<https://kitware.github.io/vtk-examples/site/>`_ "
"に掲載されている多数のコード例をご覧ください．VTKで実装されている3Dモデリング全般に関連する数学的概念の優れた入門書は，Carnegie "
"Mellon大学のKeenan Crane教授による `Discrete Differential Geometry YouTube Series "
"<https://www.youtube.com/playlist?list=PL9_jI1bdZmz0hIrNCMQW1YmZysAiIYSSS>`_"
" です．ここで紹介されている概念は，データセットがVTKのようなライブラリでどのように構造化されているかについての理解を深めるのに役立ちます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:52
msgid ""
"At the most fundamental level, all PyVista geometry classes inherit from the"
" :ref:`dataset` class. A dataset has geometry, topology, and attributes "
"describing that geometry in the form of point, cell, or field arrays."
msgstr ""
"最も基本的なレベルでは，すべての PyVista ジオメトリクラスは， :ref:`dataset` "
"クラスを継承しています．データセットは，ジオメトリ，トポロジー，そして，ポイント，セル，フィールドアレイの形でジオメトリを記述する属性を持っています．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:57
msgid ""
"Geometry in PyVista is represented as points and cells. For example, "
"consider a single cell within a |PolyData|:"
msgstr "PyVistaのジオメトリは，点とセルで表現されます． 例えば， |PolyData| の中の1つのセルを考えてみましょう．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:80
msgid ""
"We would need a way to describe the position of each of these points in "
"space, but we're limited to expressing the values themselves as we've done "
"above (lists of arrays with indices). VTK (and hence PyVista) have multiple "
"classes that represent different data shapes. The most important dataset "
"classes are shown below:"
msgstr ""
"これらの点の空間上の位置を記述する方法が必要ですが，上で行ったように値そのものを表現することには限界があります（インデックスを持つ配列のリスト）．VTKには(そしてPyVistaにも)異なるデータ形状を表す複数のクラスがあります．最も重要なデータセットクラスを以下に示します．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:0
#: ../../pyvista/doc/source/user-guide/index.rst:0
#: ../../pyvista/doc/source/user-guide/simple.rst:0
#: ../../pyvista/doc/source/user-guide/themes.rst:0
#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:0
#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:0
msgid "Static Scene"
msgstr "スタティックなシーン"

#: ../../pyvista/doc/source/user-guide/data_model.rst:0
#: ../../pyvista/doc/source/user-guide/index.rst:0
#: ../../pyvista/doc/source/user-guide/simple.rst:0
#: ../../pyvista/doc/source/user-guide/themes.rst:0
#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:0
#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:0
msgid "Interactive Scene"
msgstr "インタラクティブなシーン"

#: ../../pyvista/doc/source/user-guide/data_model.rst:94
msgid ""
"Here, the above datasets are ordered from most (5) to least complex (1). "
"That is, every dataset can be represented as an |UnstructuredGrid|, but the "
"|UnstructuredGrid| class takes the most amount of memory to store since they"
" must account for every individual point and cell . On the other hand, since"
" :vtk:`vtkImageData` (|ImageData|) is uniformly spaced, a few integers and "
"floats can describe the shape, so it takes the least amount of memory to "
"store."
msgstr ""
"ここでは，上記のデータセットを，最も複雑なもの(5)から最も複雑でないもの(1)の順に並べています．つまり，どのデータセットも "
"|UnstructuredGrid| として表現できますが，個々の点やセルを考慮しなければならないため， |UnstructuredGrid| "
"クラスは最も多くのメモリを消費します．一方， :vtk:`vtkImageData` (|ImageData|) "
"は一様な間隔で配置されているので，いくつかの整数や浮動小数点数で形状を表現することができ，格納するメモリの量は最も少なくて済みます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:104
msgid ""
"This is because in |PolyData| or |UnstructuredGrid|, points, and cells must "
"be explicitly defined. In other data types, such as |ImageData|, the cells "
"(and even points) are defined as an emergent property based on the "
"dimensionality of the grid."
msgstr ""
"これは， |PolyData| や |UnstructuredGrid| では，ポイント，やセルを明示的に定義する必要があるからです． "
"|ImageData| などの他のデータタイプでは，セル（さらにはポイント）はグリッドの次元性に基づいた創発的なプロパティとして定義されます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:110
msgid ""
"To see this in practice, let's create the simplest surface represented as a "
"|PolyData|. First, we need to define our points."
msgstr "実際には， |PolyData| で表される最も単純なサーフェスを作成してみましょう．まず，点を定義する必要があります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:115
msgid "Points and Arrays Within PyVista"
msgstr "PyVistaにおける点と配列"

#: ../../pyvista/doc/source/user-guide/data_model.rst:116
msgid ""
"There are a variety of ways to create points within PyVista, and this "
"section shows how to efficiently create an array of points by either:"
msgstr "PyVistaでは，様々な方法で点を作成することができますが，ここでは，いずれかの方法で効率的に点の配列を作成する方法を紹介します．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:118
msgid "Wrapping a VTK array"
msgstr "VTK配列のラッピング"

#: ../../pyvista/doc/source/user-guide/data_model.rst:119
msgid "Using a :class:`numpy.ndarray`"
msgstr ":class:`numpy.ndarray` の使用"

#: ../../pyvista/doc/source/user-guide/data_model.rst:120
msgid "Or just using a :class:`list`"
msgstr "または，単に :class:`list` を使うこともできます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:122
msgid ""
"PyVista provides pythonic methods for all three approaches so you can choose"
" whatever is most efficient for you. If you're comfortable with the VTK API,"
" you can choose to wrap VTK arrays, but you may find that using "
":class:`numpy.ndarray` is more convenient and avoids the looping overhead in"
" Python."
msgstr ""
"PyVistaでは，これら3つのアプローチに対応したPythonicメソッドを提供していますので，最も効率的な方法を選択することができます．VTK "
"APIに慣れている場合は，VTK配列をラップすることもできますが， :class:`numpy.ndarray` "
"を使う方が便利で，Pythonのループ処理のオーバーヘッドを避けることができるでしょう．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:129
msgid "Wrapping a VTK Array"
msgstr "VTK配列のラッピング"

#: ../../pyvista/doc/source/user-guide/data_model.rst:130
msgid ""
"Let's define points of a triangle. Using the VTK API, this can be done with:"
msgstr "3角形の点を定義してみましょう．VTKのAPIを使えば，このようなことができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:150
msgid ""
"PyVista supports creating objects directly from the :vtk:`vtkDataArray` "
"class, but there's a better, and more pythonic alternative by using "
":class:`numpy.ndarray`."
msgstr ""
"PyVistaでは， :vtk:`vtkDataArray` クラスから直接オブジェクトを作成することをサポートしていますが， "
":class:`numpy.ndarray` を使用することで，より優れた，よりpythonicな代替手段があります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:156
msgid "Using NumPy with PyVista"
msgstr "PyVistaでのNumPyの利用"

#: ../../pyvista/doc/source/user-guide/data_model.rst:157
msgid "You can create a `NumPy <https://numpy.org/>`_ points array with:"
msgstr "`NumPy <https://numpy.org/>`_ ポイントの配列を作ることができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:165
msgid ""
"We use a :class:`numpy.ndarray` here so that PyVista directly \"points\" the"
" underlying C array to VTK. VTK already has APIs to directly read in the C "
"arrays from NumPy, and since VTK is written in C++, everything from Python "
"that is transferred over to VTK needs to be in a format that VTK can "
"process."
msgstr ""
"ここでは :class:`numpy.ndarray` を使用して，PyVista が基礎となる C 配列を VTK に直接 \"指し示す\" "
"ようにしています．VTKはすでにNumPyからC配列を直接読み込むAPIを持っていますが，VTKはC++で書かれているので，PythonからVTKに転送されるすべてのものは，VTKが処理できるフォーマットである必要があります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:171
msgid ""
"Should you wish to use VTK objects within PyVista, you can still do this. In"
" fact, using :func:`pyvista.wrap`, you can even get a numpy-like "
"representation of the data. For example:"
msgstr ""
"VTKオブジェクトをPyVistaで使用したい場合は，これも可能です．実際， :func:`pyvista.wrap` を使用すると，データの "
"numpy ライクな表現を得ることもできます．例えば，次のようになります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:181
msgid ""
"Note that when wrapping the underlying VTK array, we actually perform a "
"shallow copy of the data. In other words, we pass the pointer from the "
"underlying C array to the :class:`numpy.ndarray`, meaning that the two "
"arrays are now efficiently linked (in NumPy terminology, the returned array "
"is a view into the underlying VTK data). This means that we can change the "
"array using numpy array indexing and have it modified on the \"VTK side\"."
msgstr ""
"基礎となるVTK配列をラップする際には，実際にデータの浅いコピーを行うことに注意してください．つまり，基礎となるC配列からのポインタを "
":class:`numpy.ndarray` "
"に渡すことで，2つの配列が効率的にリンクされることになります（NumPyの用語では，返される配列は基礎となるVTKデータへのビューとなります）．つまり，numpyの配列インデックスを使って配列を変更し，それを"
" \"VTK側\" で修正させることができるのです．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:194
msgid ""
"Or we can change the value from the VTK array and see it reflected in the "
"numpy wrapped array. Let's change the value back:"
msgstr "あるいは，VTK配列から値を変更して，それがnumpyのラップ配列に反映されるのを確認することもできます．それでは，値を戻してみましょう．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:204
msgid "Using Python Lists or Tuples"
msgstr "Pythonのリストやタプルの使用"

#: ../../pyvista/doc/source/user-guide/data_model.rst:205
msgid ""
"PyVista supports the use of Python sequences (that is, a :class:`list` or "
":class:`tuple`), and you could define your points using a nested list of "
"lists via:"
msgstr ""
"PyVistaでは，Pythonのシーケンス（ :class:`list` や  :class:`tuple` "
"）の使用をサポートしており，リストのネストを使ってポイントを定義することができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:213
msgid ""
"When used in the context of |PolyData| to create the mesh, this list will "
"automatically be wrapped using NumPy and then passed to VTK. This avoids any"
" looping overhead and while still allowing you to use native python classes."
msgstr ""
"メッシュを作成するために |PolyData| "
"のコンテキストで使用された場合，このリストは自動的にNumPyを使ってラップされ，VTKに渡されます．これにより，ループのオーバーヘッドを回避しつつ，ネイティブのpythonクラスを使用することができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:218
msgid ""
"Finally, let's show how we can use these three objects in the context of a "
"PyVista geometry class. Here, we create a simple point mesh containing just "
"the three points:"
msgstr ""
"最後に，この3つのオブジェクトをPyVistaのジオメトリクラスでどのように使うかを説明します．ここでは，3つの点だけを含む単純なポイントメッシュを作成します．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:228
msgid ""
"These point meshes all contain three points and are effectively identical. "
"Let's show this by accessing the underlying points array from the mesh, "
"which is represented as a :class:`pyvista.pyvista_ndarray`"
msgstr ""
"これらのポイントメッシュはすべて3つのポイントを含んでおり，実質的には同じものです． :class:`pyvista.pyvista_ndarray` "
"として表現されているメッシュから，基礎となるポイント配列にアクセスしてこれを示しましょう．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:236
msgid "And show that these are all identical"
msgstr "そして，これらがすべて同一であることを示します"

#: ../../pyvista/doc/source/user-guide/data_model.rst:244
msgid ""
"Finally, let's plot this (very) simple example using PyVista's "
":func:`pyvista.plot` method. Let's make this a full example so you can see "
"the entire process."
msgstr ""
"最後に，PyVistaの :func:`pyvista.plot` "
"メソッドを使って，この(非常に)シンプルな例をプロットしてみましょう．ここでは，全体の流れがわかるように例を挙げて説明します．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:256
msgid ""
"We'll get into PyVista's data classes and attributes later, but for now "
"we've shown how to create a simple geometry containing just points. To "
"create a surface, we must specify the connectivity of the geometry, and to "
"do that we need to specify the cells (or faces) of this surface."
msgstr ""
"PyVistaのデータクラスと属性については後ほど説明しますが，ここでは点だけを含むシンプルなジオメトリを作成する方法を紹介します．サーフェスを作成するには，ジオメトリの接続性を指定する必要がありますが，そのためにはこのサーフェスのセル（または面）を指定する必要があります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:263
msgid "Geometry and Mesh Connectivity/Topology Within PyVista"
msgstr "PyVistaにおけるジオメトリとメッシュの接続性/トポロジー"

#: ../../pyvista/doc/source/user-guide/data_model.rst:264
msgid ""
"With our previous example, we defined our \"mesh\" as three disconnected "
"points. While this is useful for representing \"point clouds,\" if we want "
"to create a surface, we have to describe the connectivity of the mesh. To do"
" this, let's define a single cell composed of three points in the same order"
" as we defined earlier."
msgstr ""
"先ほどの例では， \"メッシュ\" を切断された3つの点として定義しました．これは \"点群\" "
"を表現するのには便利ですが，サーフェイスを作成したい場合は，メッシュの接続性を記述する必要があります．そのためには，先ほど定義したのと同じ順番で3つの点からなる1つのセルを定義しましょう．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:275
msgid ""
"Observe how we had to insert a leading ``3`` to tell VTK that our face is "
"described by three elements, in this case, three points. In our |PolyData| "
"VTK doesn't assume that faces always contain three points, so we have to "
"define that. This actually gives us the flexibility to define as many (or as"
" few as one) points per cell as we wish."
msgstr ""
"VTKに面が3つの要素，この場合は，3つの点によって記述されることを伝えるために，先頭に ``3`` "
"を挿入しなければならなかったことを確認しください．私たちの |PolyData| "
"の中では，VTKは面が常に3つの点を含むことを想定していないので，私たちはそれを定義しなければなりません． "
"これにより，セルあたりの点の数を(自由に)定義できるという柔軟性が生まれます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:282
msgid "All cell types follow the same connectivity array format:"
msgstr "すべてのセルタイプは，同じ接続配列形式に従っています:"

#: ../../pyvista/doc/source/user-guide/data_model.rst:284
msgid "``[Number of points, Point 1, Point 2, ...]``"
msgstr "``[Number of points, Point 1, Point 2, ...]``"

#: ../../pyvista/doc/source/user-guide/data_model.rst:287
msgid ""
"Except for ``polyhedron`` type, in which we need to define each face of the "
"cell. The format for this type is the following:"
msgstr "ただし， ``polyhedron`` タイプは，セルの各面を定義する必要があります．このタイプのフォーマットは以下の通りです．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:290
msgid ""
"``[Number of elements, Number of faces, Face1NPoints, Point1, Point2, ..., "
"PointN, Face2NPoints, ...]``."
msgstr ""
"``[Number of elements, Number of faces, Face1NPoints, Point1, Point2, ..., "
"PointN, Face2NPoints, ...]``."

#: ../../pyvista/doc/source/user-guide/data_model.rst:292
msgid ""
"Where ``number of elements`` is the total number of elements in the array "
"that describe this cell."
msgstr "ここで ``number of elements`` は，このセルを記述する配列の要素の総数を表します．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:294
msgid ""
"Now we have all the necessary pieces to assemble an instance of |PolyData| "
"that contains a single triangle. To do this, we simply provide the "
"``points`` and ``cells`` to the constructor of a |PolyData|. We can see from"
" the representation that this geometry contains three points and one cell"
msgstr ""
"これで，単一の3角形を含む |PolyData| のインスタンスを組み立てるために必要なすべての要素が揃いました．これを実現するには，単に "
"``points`` と ``cells`` を |PolyData| "
"のコンストラクタに与えればよいのです．表現から，このジオメトリには3つのポイントと1つのセルが含まれていることがわかります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:305
msgid "Let's also plot this:"
msgstr "これもプロットしてみましょう．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:313
msgid "While we're at it, let's annotate this plot to describe this mesh."
msgstr "ついでに，このメッシュを説明するために，このプロットにアノテーションをつけてみましょう．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:332
msgid ""
"You can clearly see how the polygon is created based on the connectivity of "
"the points."
msgstr "点の接続性に基づいてポリゴンが作成される様子がよくわかります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:335
msgid ""
"This instance has several attributes to access the underlying data of the "
"mesh. For example, if you wish to access or modify the points of the mesh, "
"you can simply access the points attribute with :attr:`points "
"<pyvista.DataSet.points>`."
msgstr ""
"このインスタンスには，メッシュの基礎データにアクセスするためのいくつかの属性があります．例えば，メッシュのポイントにアクセスしたり，変更したりしたい場合は，単純に"
" :attr:`points <pyvista.DataSet.points>` でpoints属性にアクセスすることができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:344
msgid ""
"The connectivity can also be accessed from the :attr:`faces "
"<pyvista.PolyData.faces>` attribute with:"
msgstr "接続性は， :attr:`faces <pyvista.PolyData.faces>` 属性からもアクセスできます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:351
msgid "Or we could simply get the representation of the mesh with:"
msgstr "あるいは，単純にメッシュの表現を得ることができます"

#: ../../pyvista/doc/source/user-guide/data_model.rst:357
#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:254
msgid "In this representation we see:"
msgstr "この表現では，次のようになります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:359
#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:256
msgid "Number of cells :attr:`n_cells <pyvista.DataSet.n_cells>`"
msgstr "セルの数 :attr:`n_cells <pyvista.DataSet.n_cells>`"

#: ../../pyvista/doc/source/user-guide/data_model.rst:360
#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:257
msgid "Number of points :attr:`n_points <pyvista.DataSet.n_points>`"
msgstr "ポイントの数 :attr:`n_points <pyvista.DataSet.n_points>`"

#: ../../pyvista/doc/source/user-guide/data_model.rst:361
#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:258
msgid "Bounds of the mesh :attr:`bounds <pyvista.DataSet.bounds>`"
msgstr "メッシュの境界 :attr:`bounds <pyvista.DataSet.bounds>`"

#: ../../pyvista/doc/source/user-guide/data_model.rst:362
#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:259
msgid "Number of data arrays :attr:`n_arrays <pyvista.DataSet.n_arrays>`"
msgstr "データ配列の数 :attr:`n_arrays <pyvista.DataSet.n_arrays>`"

#: ../../pyvista/doc/source/user-guide/data_model.rst:364
msgid ""
"This is vastly different from the output from VTK. See "
":ref:`vtk_vs_pyvista_object_repr` for the comparison between the two "
"representations."
msgstr ""
"これはVTKからの出力とは大きく異なります． 2つの表現方法の比較については， :ref:`vtk_vs_pyvista_object_repr` "
"を参照してください．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:368
msgid ""
"This mesh contains no data arrays as it consists only of geometry. This "
"makes it useful for plotting just the geometry of the mesh, but datasets "
"often contain more than just geometry. For example:"
msgstr ""
"このメッシュは，ジオメトリのみで構成されているため，データ配列を含みません．これは，メッシュのジオメトリだけをプロットするのに便利ですが，データセットにはジオメトリ以外のものが含まれていることがよくあります．"
" 例えば"

#: ../../pyvista/doc/source/user-guide/data_model.rst:372
msgid "An electrical field computed from a changing magnetic field"
msgstr "変化する磁界から計算される電界"

#: ../../pyvista/doc/source/user-guide/data_model.rst:373
msgid "Vector field of blood flow through artery"
msgstr "動脈を流れる血流のベクトル場"

#: ../../pyvista/doc/source/user-guide/data_model.rst:374
msgid "Surface stresses from a structural finite element analysis"
msgstr "構造用有限要素法による表面応力の解析"

#: ../../pyvista/doc/source/user-guide/data_model.rst:375
msgid "Mineral deposits from geophysics"
msgstr "地球物理学から見た鉱床"

#: ../../pyvista/doc/source/user-guide/data_model.rst:376
msgid "Weather patterns as a vector field or surface data."
msgstr "ベクトル場や表面データとしての気象パターン．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:378
msgid ""
"While each one of these datasets could be represented as a different "
"geometry class, they would all contain point, cell, or field data that "
"explains the value of the data at a certain location within the geometry."
msgstr ""
"これらのデータセットはそれぞれ別のジオメトリクラスとして表現されますが，いずれもジオメトリ内の特定の場所でデータの値を説明するポイント，セル，またはフィールドデータを含んでいます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:385
msgid "Data Arrays"
msgstr "データアレイ"

#: ../../pyvista/doc/source/user-guide/data_model.rst:386
msgid ""
"Each :class:`DataSet <pyvista.DataSet>` contains attributes that allow you "
"to access the underlying numeric data. This numerical data may be associated"
" with the :attr:`points <pyvista.DataSet.points>`, cells, or not associated "
"with points or cells and attached to the mesh in general."
msgstr ""
"各 :class:`DataSet <pyvista.DataSet>` には，基礎となる数値データへのアクセスを可能にする属性が含まれています． "
"この数値データは :attr:`points <pyvista.DataSet.points>` "
"やセルに関連付けられている場合もあれば，ポイントやセルには関連付けられておらず，一般的なメッシュに関連付けられている場合もあります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:392
msgid ""
"To illustrate data arrays within PyVista, let's first construct a slightly "
"more complex mesh than our previous example. Here, we create a simple mesh "
"containing four isometric cells by starting with a |ImageData| and then "
"casting it to an |UnstructuredGrid| with :func:`cast_to_unstructured_grid() "
"<pyvista.DataSet.cast_to_unstructured_grid>`."
msgstr ""
"PyVistaでのデータ配列を説明するために，まず先ほどの例よりも少し複雑なメッシュを作ってみましょう． ここでは，まず |ImageData| "
"から始めて， :func:`cast_to_unstructured_grid() "
"<pyvista.DataSet.cast_to_unstructured_grid>` で |UnstructuredGrid| "
"にキャストすることで，4つのアイソメトリックなセルを含む単純なメッシュを作成します．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:405
msgid "Let's also plot this basic mesh:"
msgstr "また，この基本的なメッシュをプロットしてみましょう．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:430
msgid ""
"Now that we have a simple mesh to work with, we can start assigning it data."
" There are two main types of data that can be associated with a mesh: scalar"
" data and vector data. Scalar data is single or multi-component data that is"
" non directional and may include values like temperature, or in the case of "
"multi-component data, RGBA values. Vector data has magnitude and direction "
"and is represented as arrays containing three components per data point."
msgstr ""
"さて，シンプルなメッシュができあがったところで，データの割り当てを始めましょう． "
"メッシュに関連付けられるデータには，主にスカラーデータとベクトルデータの2種類があります．スカラーデータとは，単一または複数コンポーネントのデータで，方向性がなく，温度などの値や，複数コンポーネントのデータの場合はRGBA値などを含みます．ベクトルデータは，大きさと方向性を持ち，1つのデータポイントに3つの成分を含む配列として表現されます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:438
msgid ""
"When plotting, we can easily display scalar data, but this data must be "
"\"associated\" with either points or cells. For example, we may wish to "
"assign values to the cells of our example mesh, which we can do by accessing"
" the :attr:`cell_data <pyvista.DataSet.cell_data>` attribute of our mesh."
msgstr ""
"プロットする際には，スカラーデータを簡単に表示することができますが，このデータはポイントまたはセルに \"関連付け\" られている必要があります． "
"例えば，サンプルのメッシュのセルに値を割り当てたい場合，メッシュの :attr:`cell_data "
"<pyvista.DataSet.cell_data>` 属性にアクセスすることで実現できます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:449
#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:165
msgid "Cell Data"
msgstr "セルデータ"

#: ../../pyvista/doc/source/user-guide/data_model.rst:450
msgid ""
"The easiest way to add scalar data to a :class:`DataSet <pyvista.DataSet>` "
"is to use the ``[]`` operator. Continuing with our example above, let's "
"assign each cell a single integer. We can do this using a Python "
":class:`list` and making it the same length as the number of cells in the "
"|UnstructuredGrid|. Or as an even simpler example, using a :class:`range` of"
" the appropriate length. Here we create the range, add it to the "
":attr:`cell_data <pyvista.DataSet.cell_data>`, and then access it using the "
"``[]`` operator."
msgstr ""
":class:`DataSet <pyvista.DataSet>` にスカラーデータを追加する最も簡単な方法は， ``[]`` "
"演算子を使うことです．上の例を続けて，各セルに1つの整数を割り当ててみましょう． これにはPythonの :class:`list` を使い， "
"|UnstructuredGrid| のセル数と同じ長さにすることができます．また，もっと単純な例として，適切な長さの :class:`range` "
"を使用することもできます． ここでは，レンジを作成して :attr:`cell_data <pyvista.DataSet.cell_data>` "
"に追加し， ``[]`` 演算子を使ってアクセスしています．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:466
msgid ""
"Note how we are returned a :class:`pyvista.pyvista_ndarray`. Since VTK "
"requires C arrays, PyVista will internally wrap or convert all inputs to C "
"arrays. We can then plot this with:"
msgstr ""
"どのように :class:`pyvista.pyvista_ndarray` が返されるかに注目してください． "
"VTKはC言語の配列を必要とするので，PyVistaは内部的にすべての入力をC言語の配列にラップまたは変換します． "
"そして，これを次のようにしてプロットします．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:481
msgid ""
"Note how we did not have to specify which cell data to plot as the ``[]`` "
"operator automatically sets the active scalars:"
msgstr ""
"``[]`` 演算子が自動的にアクティブなスカラーを設定するので，どのセルデータをプロットするかを指定する必要がないことに注目してください．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:488
msgid ""
"We can also add labels to our plot to show which cells are assigned which "
"scalars. Note how this is in the same order as the scalars we assigned."
msgstr ""
"また，どのセルにどのスカラーが割り当てられているかを示すために，プロットにラベルを追加することもできます． "
"割り当てられたスカラーと同じ順番になっていることに注目してください．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:503
msgid ""
"We can continue to assign cell data to our :class:`DataSet "
"<pyvista.DataSet>` using the ``[]`` operator, but if you do not wish the new"
" array to become the active array, you can add it using :func:`set_array() "
"<pyvista.DataSetAttributes.set_array>`"
msgstr ""
"``[]`` 演算子を使って :class:`DataSet <pyvista.DataSet>` "
"にセルデータを割り当て続けることができますが，新しいアレイをアクティブなアレイにしたくない場合は， :func:`set_array() "
"<pyvista.DataSetAttributes.set_array>` を使って追加することができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:514
msgid ""
"Now, ``ugrid`` contains two arrays, one of which is the \"active\" scalars. "
"This set of active scalars will be the one plotted automatically when "
"``scalars`` is unset in either :func:`add_mesh() <pyvista.Plotter.add_mesh>`"
" or :func:`pyvista.plot`. This makes it possible to have many cell arrays "
"associated with a dataset and track which one will plotted as the active "
"cell scalars by default."
msgstr ""
"これで ``ugrid`` には2つの配列が入り，そのうちの1つが \"アクティブな\" スカラーとなります． このアクティブなスカラーのセットは， "
":func:`add_mesh() <pyvista.Plotter.add_mesh>` や :func:`pyvista.plot` で "
"``scalars`` が設定されていない場合に，自動的にプロットされるものです． "
"これにより，データセットに関連付けられた多くのセルアレイを持ち，どのセルアレイがデフォルトでアクティブなセルスカラーとしてプロットされるかを追跡することが可能になります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:521
msgid ""
"The active scalars can also be accessed via :attr:`active_scalars "
"<pyvista.DataSet.active_scalars>`, and the name of the active scalars array "
"can be accessed or set with :attr:`active_scalars_name "
"<pyvista.DataSet.active_scalars_name>`."
msgstr ""
"また，アクティブなスカラーは :attr:`active_scalars <pyvista.DataSet.active_scalars>` "
"でアクセスでき，アクティブなスカラー配列の名前は :attr:`active_scalars_name "
"<pyvista.DataSet.active_scalars_name>` でアクセスまたは設定することができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:534
#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:151
msgid "Point Data"
msgstr "ポイントデータ"

#: ../../pyvista/doc/source/user-guide/data_model.rst:535
msgid ""
"Data can be associated to points in the same manner as in "
":ref:`pyvista_data_model_cell_data`. The :attr:`point_data "
"<pyvista.DataSet.point_data>` attribute allows you to associate point data "
"to the points of a :class:`DataSet <pyvista.DataSet>`. Here, we will "
"associate a simple list to the points using the ``[]`` operator."
msgstr ""
"データは :ref:`pyvista_data_model_cell_data` と同様の方法でポイントに関連付けることができます． "
":attr:`point_data <pyvista.DataSet.point_data>` 属性を使うと， :class:`DataSet "
"<pyvista.DataSet>` のポイントにポイントデータを関連付けることができます． ここでは， ``[]`` "
"演算子を使って，単純なリストをポイントに関連付けることにします．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:548
msgid ""
"Again, these values become the active scalars in our point arrays by default"
" by using the ``[]`` operator:"
msgstr "繰り返しになりますが，これらの値は， ``[]`` 演算子を用いることで，デフォルトで点群のアクティブなスカラーとなります．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:555
msgid ""
"Let's plot the point data. Note how this varies from the cell data plot; "
"each individual point is assigned a scalar value which is interpolated "
"across a cell to create a smooth color map between the lowest value at "
"``Point 0`` to the highest value at ``Point 8``."
msgstr ""
"ポイントデータをプロットしてみましょう． 各ポイントにはスカラー値が割り当てられており，それがセル全体を補間して，最も低い値の ``Point 0`` "
"から最も高い値の ``Point 8`` までの間の滑らかなカラーマップを作成しています．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:582
msgid ""
"As in :ref:`pyvista_data_model_cell_data`, we can assign multiple arrays to "
":attr:`point_data <pyvista.DataSet.point_data>` using :func:`set_array() "
"<pyvista.DataSetAttributes.set_array>`."
msgstr ""
"また， :ref:`pyvista_data_model_cell_data` と同様に， :func:`set_array() "
"<pyvista.DataSetAttributes.set_array>` を使って， :attr:`point_data "
"<pyvista.DataSet.point_data>` に複数の配列を割り当てることができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:592
msgid ""
"Again, here there are now two arrays associated to the point data, and only "
"one is the \"active\" scalars array. Like as in the cell data, we can "
"retrieve this with :attr:`active_scalars <pyvista.DataSet.active_scalars>`, "
"and the name of the active scalars array can be accessed or set with "
":attr:`active_scalars_name <pyvista.DataSet.active_scalars_name>`."
msgstr ""
"ここでも，ポイントデータには2つの配列が関連付けられており，1つだけが \"アクティブ\" なスカラー配列となっています． "
"また，アクティブなスカラー配列の名前は， :attr:`active_scalars_name "
"<pyvista.DataSet.active_scalars_name>` でアクセスまたは設定することができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:607
msgid "Dataset Active Scalars"
msgstr "データセットアクティブスカラー"

#: ../../pyvista/doc/source/user-guide/data_model.rst:608
msgid ""
"Continuing from the previous sections, our ``ugrid`` dataset now contains "
"both point and cell data:"
msgstr "前節に引き続き，今回の ``ugrid`` データセットには，ポイントデータとセルデータの両方が含まれています．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:619
msgid ""
"There are active scalars in both point and cell data, but only one type of "
"scalars can be \"active\" at the dataset level. The reason for this is that "
"only one scalar type (be it point or cell) can be plotted at once, and this "
"data can be obtained from :attr:`active_scalars_info "
"<pyvista.DataSet.active_scalars_info>`:"
msgstr ""
"(ポイントデータにもセルデータにも)アクティブなスカラーがありますが，データセットレベルでは1種類のスカラーしか \"アクティブ\" にできません． "
"このデータは :attr:`active_scalars_info <pyvista.DataSet.active_scalars_info>` "
"から得ることができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:629
msgid ""
"Note that the active scalars are by default the point scalars. You can "
"change this by setting the active scalars with :func:`set_active_scalars() "
"<pyvista.DataSet.set_active_scalars>`. Note that if you want to set the "
"active scalars and both the point and cell data have an array of the same "
"name, you must specify the ``preference``:"
msgstr ""
"アクティブなスカラーはデフォルトではポイントスカラーであることに注意してください． これは :func:`set_active_scalars() "
"<pyvista.DataSet.set_active_scalars>` でアクティブなスカラーを設定することで変更することができます． "
"アクティブなスカラーを設定したいときに，ポイントデータとセルデータの両方に同じ名前の配列がある場合は， ``preference`` "
"を指定しなければならないことに注意してください．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:641
msgid ""
"This can also be set when plotting using the ``preference`` parameter in "
":func:`add_mesh() <pyvista.Plotter.add_mesh>` or :func:`pyvista.plot`."
msgstr ""
"これは， :func:`add_mesh() <pyvista.Plotter.add_mesh>` や :func:`pyvista.plot` の "
"``preference`` パラメータを使用して，プロットする際に設定することもできます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:647
#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:198
msgid "Field Data"
msgstr "フィールドデータ"

#: ../../pyvista/doc/source/user-guide/data_model.rst:648
msgid ""
"Field arrays are different from :attr:`point_data "
"<pyvista.DataSet.point_data>` and :attr:`cell_data "
"<pyvista.DataSet.cell_data>` in that they are not associated with the "
"geometry of the :class:`DataSet <pyvista.DataSet>`. This means that while "
"it's not possible to designate the field data as active scalars or vectors, "
"you can use it to \"attach\" arrays of any shape. You can even add string "
"arrays in the field data:"
msgstr ""
"フィールド配列は， :attr:`point_data <pyvista.DataSet.point_data>` や :attr:`cell_data"
" <pyvista.DataSet.cell_data>` とは異なり， :class:`DataSet <pyvista.DataSet>` "
"のジオメトリとは関連付けられていません．つまり，フィールドデータをアクティブなスカラーやベクターとして指定することはできませんが，これを使って任意の形状の配列を"
" \"添付\" することができます． フィールドデータに文字列配列を追加することもできます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:661
msgid ""
"Note that the field data is automatically transferred to VTK C-style arrays "
"and then represented as a numpy data format."
msgstr "なお，フィールドデータは自動的にVTK Cスタイルの配列に転送され，numpyのデータ形式で表現されます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:664
msgid ""
"When listing the current field data, note that the association is \"NONE\":"
msgstr "現在のフィールドデータをリストアップする際には，associationが \"NONE \"であることに注意してください．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:670
msgid ""
"This is because the data is not associated with points or cells, and cannot "
"be made so because field data is not expected to match the number of cells "
"or points. As such, it also cannot be plotted."
msgstr ""
"これは，データがポイントやセルに関連付けられていないためであり，フィールドデータがセルやポイントの数と一致することは期待できないため，そうすることはできません．"
" そのため，プロットすることもできません．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:676
msgid "Vectors, Texture Coords, and Normals Attributes"
msgstr "ベクトル，テクスチャコード，および法線の属性"

#: ../../pyvista/doc/source/user-guide/data_model.rst:677
msgid ""
"Both cell and point data can also store the following \"special\" attributes"
" in addition to :attr:`active_scalars <pyvista.DataSet.active_scalars>`:"
msgstr ""
"セルとポイントの両方のデータは， :attr:`active_scalars <pyvista.DataSet.active_scalars>` "
"に加えて，以下の \"特別な\" 属性を保存することができます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:679
msgid ":attr:`active_normals <pyvista.DataSet.active_normals>`"
msgstr ":attr:`active_normals <pyvista.DataSet.active_normals>`"

#: ../../pyvista/doc/source/user-guide/data_model.rst:680
msgid ":attr:`active_t_coords <pyvista.DataSet.active_t_coords>`"
msgstr ":attr:`active_t_coords <pyvista.DataSet.active_t_coords>`"

#: ../../pyvista/doc/source/user-guide/data_model.rst:681
msgid ":attr:`active_vectors <pyvista.DataSet.active_vectors>`"
msgstr ":attr:`active_vectors <pyvista.DataSet.active_vectors>`"

#: ../../pyvista/doc/source/user-guide/data_model.rst:685
msgid "Active Normals"
msgstr "アクティブな法線"

#: ../../pyvista/doc/source/user-guide/data_model.rst:686
msgid ""
"The :attr:`active_normals <pyvista.DataSet.active_normals>` array is a "
"special array that specifies the local normal direction of meshes. It is "
"used for creating physically based rendering, rendering smooth shading using"
" Phong interpolation, warping by scalars, etc. If this array is not set when"
" plotting with ``smooth_shading=True`` or ``pbr=True``, it will be computed."
msgstr ""
":attr:`active_normals <pyvista.DataSet.active_normals>` "
"の配列は，メッシュのローカルな法線方向を指定する特別な配列です．物理ベースのレンダリングの作成，Phong補間を用いたスムーズなシェーディングのレンダリング，スカラーによるワープなどに使用されます．"
" もし， ``smooth_shading=True`` や ``pbr=True`` "
"を用いてプロットする際に，この配列が設定されていない場合は，計算されます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:696
msgid "Active Texture Coordinates"
msgstr "アクティブテクスチャの座標"

#: ../../pyvista/doc/source/user-guide/data_model.rst:697
msgid ""
"The :attr:`active_t_coords <pyvista.DataSet.active_t_coords>` array is used "
"for rendering textures. See :ref:`texture_example` for examples using this "
"array."
msgstr ""
":attr:`active_t_coords <pyvista.DataSet.active_t_coords>` "
"の配列は，テクスチャのレンダリングに使用されます． この配列を使った例については， :ref:`texture_example` を参照してください．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:704
msgid "Active Vectors"
msgstr "アクティブベクター"

#: ../../pyvista/doc/source/user-guide/data_model.rst:705
msgid ""
"The :attr:`active_vectors <pyvista.DataSet.active_vectors>` is an array "
"containing quantities that have magnitude and direction (specifically, three"
" components). For example, a vector field containing the wind speed at "
"various coordinates. This differs from :attr:`active_scalars "
"<pyvista.DataSet.active_scalars>` as scalars are expected to be non-"
"directional even if they contain several components (as in the case of RGB "
"data)."
msgstr ""
":attr:`active_vectors <pyvista.DataSet.active_vectors>` "
"は，大きさと方向（具体的には，3つの成分）を持つ量を含む配列です． 例えば，様々な座標における風速を含むベクトルフィールドです． これは "
":attr:`active_scalars <pyvista.DataSet.active_scalars>` "
"とは異なります．スカラーはいくつかの成分を含んでいても，（RGBデータの場合のように）無指向性であることが期待されます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:714
msgid ""
"Vectors are treated differently within VTK than scalars when performing "
"transformations using the :func:`~pyvista.DataObjectFilters.transform` "
"filter. Unlike scalar arrays, vector arrays will be transformed along with "
"the geometry as these vectors represent quantities with direction."
msgstr ""
"VTKでは， :func:`~pyvista.DataObjectFilters.transform` "
"フィルタを使用して変換を行う際に，ベクトルはスカラーとは異なる扱いになります． "
"スカラー配列とは異なり，ベクトル配列は方向を持つ量を表すため，ジオメトリと一緒に変換されます．"

#: ../../pyvista/doc/source/user-guide/data_model.rst:721
msgid ""
"VTK permits only one \"active\" vector. If you have multiple vector arrays "
"that you wish to transform, set ``transform_all_input_vectors=True`` in "
":func:`~pyvista.DataObjectFilters.transform`. Be aware that this will "
"transform any array with three components, so multi-component scalar arrays "
"like RGB arrays will have to be discarded after transformation."
msgstr ""
"VTKでは，1つの \"アクティブ\" なベクトルしか許可しません．変換したい複数のベクトル配列がある場合には，  "
":func:`~pyvista.DataObjectFilters.transform` で "
"``transform_all_input_vectors=True`` を設定してください． "
"これは，3つのコンポーネントを持つ配列を変換するので，RGB配列のような複数コンポーネントのスカラー配列は，変換後に破棄しなければならないことに注意してください．"

#: ../../pyvista/doc/source/user-guide/index.rst:2
msgid "User Guide"
msgstr "ユーザーガイド"

#: ../../pyvista/doc/source/user-guide/index.rst:3
msgid ""
"This section details the general usage of PyVista for users who may or may "
"not have used VTK in the past, but are looking to leverage it in a Pythonic "
"manner for 3D plotting. See the table of contents below or the in the side "
"panel for the individual sections demonstrating the key concepts of PyVista."
msgstr ""
"このセクションでは，PyVistaの一般的な使用方法について，過去にVTKを使用したことがあるかどうかにかかわらず，3DプロットのためにPython的な方法で利用しようとしているユーザーを対象に説明します．PyVistaの主要な概念を示す個々のセクションについては，以下の目次またはサイドパネルのを参照してください．"

#: ../../pyvista/doc/source/user-guide/index.rst:11
msgid "Simple Interactive Example"
msgstr "単純な対話型の例"

#: ../../pyvista/doc/source/user-guide/index.rst:12
msgid "This basic example demonstrates three key features of PyVista:"
msgstr "この基本的な例は，PyVistaの3つの主要な機能を示しています．"

#: ../../pyvista/doc/source/user-guide/index.rst:14
msgid "Simple `numpy`_ and `matplotlib`_ like interface"
msgstr "単純な `numpy`_ と `matplotlib`_ のようなインターフェース"

#: ../../pyvista/doc/source/user-guide/index.rst:15
msgid "Variety of built-in examples"
msgstr "様々な組込み例"

#: ../../pyvista/doc/source/user-guide/index.rst:16
msgid "Intuitive plotting with keyword arguments."
msgstr "キーワード引数を使用した直感的なプロット"

#: ../../pyvista/doc/source/user-guide/index.rst:35
msgid ""
"Here, we download the `Stanford dragon mesh "
"<http://graphics.stanford.edu/data/3Dscanrep/>`_, color it according to "
"height, and plot it using a web-viewer. This same example will run "
"identically locally."
msgstr ""
"ここでは， `Stanford dragon mesh <http://graphics.stanford.edu/data/3Dscanrep/>`_"
" をダウンロードし，高さに応じて色分けし，Webビューアを使用してプロットします．この同じ例は，ローカルで同じように実行されます．"

#: ../../pyvista/doc/source/user-guide/index.rst:49
msgid ""
"With just a few lines of code we downloaded a sample mesh from the web, "
"added scalars to it based on the points of the mesh, and plotted it while "
"controlling the orientation, color, and data presented in the visualization."
msgstr ""
"ほんの数行のコードで，Webからサンプルメッシュをダウンロードし，メッシュのポイントに基づいてスカラーを追加し，可視化で表示される方向，色，およびデータを制御しながらプロットしました．"

#: ../../pyvista/doc/source/user-guide/index.rst:54
msgid ""
"The following sections explain the details of the how and why of PyVista's "
"interface."
msgstr "以下のセクションでは，PyVistaのインタフェースの仕組みと理由について詳しく説明します．"

#: ../../pyvista/doc/source/user-guide/index.rst:58
msgid "User Guide Contents"
msgstr "ユーザーガイドの内容"

#: ../../pyvista/doc/source/user-guide/index.rst:72
msgid "Videos"
msgstr "ビデオ"

#: ../../pyvista/doc/source/user-guide/index.rst:73
msgid "Here are some videos that you can watch to learn PyVista:"
msgstr "PyVistaについて学ぶために見ることができるいくつかのビデオを以下に示します:"

#: ../../pyvista/doc/source/user-guide/index.rst:75
msgid ""
"PyConJP2020 talk \"How to plot unstructured mesh file on Jupyter Notebook\" "
"(15 minutes):"
msgstr ""
"PyConJP 2020 トーク \"How to plot unstructured mesh file on Jupyter Notebook\""
"  (15分):"

#: ../../pyvista/doc/source/user-guide/index.rst:78
msgid "`Video <https://youtu.be/X3Z54Kw4I6Y>`_"
msgstr "`ビデオ <https://youtu.be/X3Z54Kw4I6Y>`_"

#: ../../pyvista/doc/source/user-guide/index.rst:79
msgid ""
"`Material "
"<https://docs.google.com/presentation/d/1M_cnS66ja81u_mHACjaUsDj1wSeeEtnEevk_IMZ8-dg/edit?usp=sharing>`_"
msgstr ""
"`材料 "
"<https://docs.google.com/presentation/d/1M_cnS66ja81u_mHACjaUsDj1wSeeEtnEevk_IMZ8-dg/edit?usp=sharing>`_"

#: ../../pyvista/doc/source/user-guide/index.rst:81
msgid "Software Underground Tutorial"
msgstr "Software Underground Tutorial"

#: ../../pyvista/doc/source/user-guide/index.rst:83
msgid "`Tutorial: PyVista <https://www.youtube.com/watch?v=FmNmRBsEBHE>`_"
msgstr "`Tutorial: PyVista <https://www.youtube.com/watch?v=FmNmRBsEBHE>`_"

#: ../../pyvista/doc/source/user-guide/index.rst:85
msgid ""
"If there is any material that we can add, please open an `issue "
"<https://github.com/pyvista/pyvista/issues>`_ ."
msgstr ""
"追加できる資料があれば， `issue <https://github.com/pyvista/pyvista/issues>`_ を開いてください．"

#: ../../pyvista/doc/source/user-guide/jupyter/index.rst:4
msgid "Jupyter Notebook Plotting"
msgstr "Jupyterノートブックプロット"

#: ../../pyvista/doc/source/user-guide/jupyter/index.rst:5
msgid ""
"Plot with ``pyvista`` interactively within a `Jupyter "
"<https://jupyter.org/>`_ notebook."
msgstr "`Jupyter <https://jupyter.org/>`_ ノートで ``pyvista`` でインタラクティブにプロットします．"

#: ../../pyvista/doc/source/user-guide/jupyter/index.rst:9
msgid "We recommend using the Trame-based backed. See :ref:`trame_jupyter`."
msgstr "Trameベースの後援を使用することをお勧めします． :ref:`trame_jupyter` を参照してください．"

#: ../../pyvista/doc/source/user-guide/jupyter/index.rst:13
msgid "Supported Modules"
msgstr "サポートされるモジュール"

#: ../../pyvista/doc/source/user-guide/jupyter/index.rst:14
msgid ""
"The PyVista module supports a variety of backends when plotting within a "
"jupyter notebook:"
msgstr "PyVistaモジュールは，Jupyterノートブック内でプロットする際のさまざまなバックエンドをサポートしています:"

#: ../../pyvista/doc/source/user-guide/jupyter/index.rst:17
msgid ""
"Server and client-side rendering with PyVista streaming to the notebook "
"through `trame <https://github.com/Kitware/trame/>`_"
msgstr ""
"`trame <https://github.com/Kitware/trame/>`_ "
"を介したノートブックへのPyVistaストリーミングによるサーバとクライアント側のレンダリング"

#: ../../pyvista/doc/source/user-guide/jupyter/index.rst:19
msgid "Static images."
msgstr "静止画像．"

#: ../../pyvista/doc/source/user-guide/jupyter/index.rst:29
msgid "Usage with PyVista"
msgstr "PyVistaでの使用法"

#: ../../pyvista/doc/source/user-guide/jupyter/index.rst:30
msgid ""
"There are two ways to set the jupyter plotting backend. First, it can be "
"done on a plot by plot basis by setting the ``jupyter_backend`` parameter in"
" either :func:`Plotter.show() <pyvista.Plotter.show>` or "
":func:`dataset.plot() <pyvista.DataSet.plot>`. You can also set it globally "
"with the :func:`pyvista.set_jupyter_backend`. For further details:"
msgstr ""
"jupyterのプロッティングバックエンドを設定するには2つの方法があります． まず， :func:`Plotter.show() "
"<pyvista.Plotter.show>` や :func:`dataset.plot() <pyvista.DataSet.plot>` の "
"``jupyter_backend` パラメータを設定することで，プロットごとに設定することができます． また， "
":func:`pyvista.set_jupyter_backend` でグローバルに設定することもできます． 詳細はこちらをご覧ください．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:2
msgid "Set the plotting backend for a jupyter notebook."
msgstr "Jupyterノートブックのプロットバックエンドを設定します．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:0
msgid "Parameters"
msgstr "パラメータ"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:7
msgid "**backend** : :class:`python:str`"
msgstr "**backend** : :class:`python:str`"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:6
msgid "python:str"
msgstr "python:str"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:8
msgid "Jupyter backend to use when plotting.  Must be one of the following:"
msgstr "プロット時に使用するJupyterバックエンドです．次のいずれかである必要があります．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:10
msgid ""
"``'static'`` : Display a single static image within the Jupyterlab "
"environment.  Still requires that a virtual framebuffer be set up when "
"displaying on a headless server, but does not require any additional modules"
" to be installed."
msgstr ""
"``'static'`` : "
"Jupyterlab環境内に単一の静的イメージを表示します．ヘッドレスサーバーで表示する場合も仮想フレームバッファをセットアップする必要がありますが，追加のモジュールをインストールする必要はありません．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:15
msgid ""
"``'client'`` : Export/serialize the scene graph to be rendered with VTK.js "
"client-side through ``trame``. Requires ``trame`` and ``jupyter-server-"
"proxy`` to be installed."
msgstr ""
"``'client'`` : VTK.jsのクライアントサイドでレンダリングするシーングラフを， ``trame`` "
"を通してエクスポート/シリアライズすることができます． ``trame`` と ``jupyter-server-proxy`` "
"がインストールされている必要があります．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:19
msgid ""
"``'server'``: Render remotely and stream the resulting VTK images back to "
"the client using ``trame``. This replaces the ``'ipyvtklink'`` backend with "
"better performance. Supports the most VTK features, but suffers from minor "
"lag due to remote rendering. Requires that a virtual framebuffer be set up "
"when displaying on a headless server. Must have at least ``trame`` and "
"``jupyter-server-proxy`` installed for cloud/remote Jupyter instances. This "
"mode is also aliased by ``'trame'``."
msgstr ""
"``'server'``: リモートでレンダリングを行い，生成されたVTKイメージを ``trame`` "
"を用いてクライアントにストリームバックします．これは ``'ipyvtklink'`` "
"バックエンドを置き換えるもので，より良いパフォーマンスを発揮します．ほとんどの VTK "
"機能をサポートしていますが，リモートレンダリングによる小さな遅延に悩まされています．ヘッドレスサーバで表示する場合は，仮想フレームバッファをセットアップする必要があります．クラウド/リモートJupyterインスタンスでは，少なくとも"
" ``trame`` と ``jupyter-server-proxy`` がインストールされている必要があります．このモードは ``'trame'``"
" というエイリアスでもあります．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:28
msgid ""
"``'trame'``: The full Trame-based backend that combines both ``'server'`` "
"and ``'client'`` into one backend. This requires a virtual frame buffer."
msgstr ""
"``'trame'``: ``'server'`` と ``'client'`` "
"の両方を一つのバックエンドに統合したTrameベースのフルバックエンドです．これには仮想フレームバッファが必要です．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:32
msgid ""
"``'html'`` : Export/serialize the scene graph to be rendered with the Trame "
"client backend but in a static HTML file."
msgstr ""
"``'html'`` : "
"Trameクライアントバックエンドでレンダリングされるシーングラフを，静的なHTMLファイルにエクスポート/シリアライズします．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:35
msgid ""
"``'none'`` : Do not display any plots within jupyterlab, instead display "
"using dedicated VTK render windows.  This will generate nothing on headless "
"servers even with a virtual framebuffer."
msgstr ""
"``'none'`` : "
"jupyterlab内にプロットを表示せず，専用のVTKレンダリングウィンドウを使用して表示します．これは，仮想フレームバッファがあっても，ヘッドレスサーバー上では何も生成しません．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:40
msgid "**name** : :class:`python:str`, :obj:`optional`"
msgstr "**name** : :class:`python:str`, :obj:`optional`"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:39
msgid "python:str, optional"
msgstr "python:str, optional"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:41
msgid "The unique name identifier for the server."
msgstr "サーバー固有の名前識別子．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:43
msgid "**\\*\\*kwargs** : :class:`python:dict`, :obj:`optional`"
msgstr "**\\*\\*kwargs** : :class:`python:dict`, :obj:`optional`"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:42
msgid "python:dict, optional"
msgstr "python:dict, optional"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:44
msgid "Any additional keyword arguments to pass to the server launch."
msgstr "サーバー起動に渡す追加のキーワード引数．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:59
msgid "Examples"
msgstr "例"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:60
msgid "Enable the trame Trame backend."
msgstr "Trameバックエンドを有効にします．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:64
msgid "Just show static images."
msgstr "静止画像を表示するだけです．"

#: ../../../../../../../opt/hostedtoolcache/Python/3.13.5/x64/lib/python3.13/site-packages/pyvista/jupyter/__init__.pydocstring
#: of pyvista.jupyter.set_jupyter_backend:68
msgid ""
"Disable all plotting within JupyterLab and display using a standard desktop "
"VTK render window."
msgstr "JupyterLab内のすべてのプロットを無効にし，準のデスクトップVTKレンダリングウィンドウを使用して表示します．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:4
msgid "Trame Jupyter Backend for PyVista"
msgstr "PyVista用Jupyterバックエンドをtrame化する"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:6
msgid ""
"PyVista has the ability to display fully featured plots within a Jupyter "
"environment using `Trame <https://kitware.github.io/trame/index.html>`_. We "
"provide mechanisms to pair PyVista and Trame so that PyVista plotters can be"
" used in a web context with both server and client-side rendering."
msgstr ""
"PyVistaは， `Trame <https://kitware.github.io/trame/index.html>`_ "
"を使用して，Jupyter環境内で完全な機能を持つプロットを表示する機能を備えています．私たちは，PyVistaとTrameをペアリングするメカニズムを提供し，PyVistaプロッタを，サーバーサイドとクライアントサイドの両方のレンダリングでWebコンテキストで使用できるようにします．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:11
msgid ""
"The server-side rendering mode of the Trame backend works by streaming the "
"current render window to a canvas within Jupyter and then passing any user "
"actions from the canvas back to the VTK render window (this is done under "
"the hood by the ``vtkRemoteView`` in ``trame-vtk``."
msgstr ""
"Trameバックエンドのサーバーサイドレンダリングモードは，現在のレンダーウィンドウをJupyter内のcanvasにストリーミングし，canvasからのユーザーアクションをVTKレンダーウィンドウに戻すことで動作します（これは，"
" ``trame-vtk`` の ``vtkRemoteView`` がアンダーグラウンドで行います．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:16
msgid ""
"For example, both sections of code will display an interactive canvas within"
" Jupyter:"
msgstr "たとえば，コードの両方のセクションは，Jupyter内に対話型キャンバスを表示します．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:33
msgid "For convenience, you can enable ``trame`` by default with:"
msgstr "便宜上， ``trame`` をデフォルトで有効にするには，次のコマンドを使用します．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:43
msgid "Trame Jupyter Modes"
msgstr "Trame Jupyterのモード"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:45
msgid ""
"The PyVista Trame jupyter backend provides three modes of operation "
"(technically as three separate backend choices):"
msgstr "PyVista Trameのjupyterバックエンドは，3つの動作モード(厳密には3つの別々のバックエンドの選択肢として)を提供します．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:48
msgid ""
"``'trame'``: Uses a view that can switch between client- and server-"
"rendering modes."
msgstr "``'trame'``: クライアントとサーバーのレンダリングモードを切り替えることができるビューを使用します．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:49
msgid "``'server'``: Uses a view that is purely server-rendering."
msgstr "``'server'``: 純粋なサーバーレンダリングであるビューを使用します．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:50
msgid ""
"``'client'``: Uses a view that is purely client-rendering (generally safe "
"without a virtual frame buffer)"
msgstr "``'client'``: 純粋なクライアントレンダリングを行うビューを使用します (仮想フレームバッファがなくても一般的に安全です)"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:52
msgid ""
"You can choose your backend either by using :func:`set_jupyter_backend() "
"<pyvista.set_jupyter_backend>` or passing ``jupyter_backend`` on the "
":func:`show() <pyvista.Plotter.show>` call."
msgstr ""
"バックエンドは :func:`set_jupyter_backend() <pyvista.set_jupyter_backend>` を使用するか， "
":func:`show() <pyvista.Plotter.show>` のコールで ``jupyter_backend`` "
"を渡すことによって選択することができます．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:76
msgid "Installation"
msgstr "インストール"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:78
msgid "Using pip, you can set up your jupyter environment with:"
msgstr "pipを使って，次のようにしてjupyter環境をセットアップすることができます．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:86
msgid "Remote Jupyter Host"
msgstr "リモートJupyterホスト"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:88
msgid ""
"When using PyVista in Jupyter that is hosted remotely (docker, cloud "
"JupyterHub, binder, or otherwise), you will need to pair the Trame backend "
"with either ``jupyter-server-proxy`` or ``trame-jupyter-extension``."
msgstr ""
"リモートでホストされているJupyter (docker, cloud JupyterHub, binder, "
"若しくはその他)でPyVistaを使用する場合，Trameバックエンドと ``jupyter-server-proxy`` と ``trame-"
"jupyter-extension`` いずれもペアリングする必要があります．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:94
msgid "Jupyter Server Proxy"
msgstr "Jupyter サーバープロキシ"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:96
msgid ""
"`Jupyter Server Proxy <https://jupyter-server-"
"proxy.readthedocs.io/en/latest/>`_ lets you access the Trame server hosting "
"the views of the PyVista plotters alongside your notebook, and provide "
"authenticated web access to them directly through Jupyter."
msgstr ""
"`Jupyter Server Proxy <https://jupyter-server-"
"proxy.readthedocs.io/en/latest/>`_ "
"は，ノートブックと一緒にPyVistaプロッタのビューをホストするTrameサーバにアクセスし，Jupyterから直接認証されたウェブアクセスを提供することができます．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:101
msgid ""
"To configure PyVista and Trame to work with ``jupyter-server-proxy`` in a "
"remote environment, you will need to set some options on the global PyVista "
"theme:"
msgstr ""
"リモート環境で ``jupyter-server-proxy`` を使って動作するように PyVista と Trame を設定するには，PyVista"
" のグローバルテーマでいくつかのオプションを設定する必要があります．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:104
#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:165
msgid ""
":py:attr:`pyvista.global_theme.trame.server_proxy_enabled "
"<pyvista.plotting.themes._TrameConfig.server_proxy_enabled>`"
msgstr ""
":py:attr:`pyvista.global_theme.trame.server_proxy_enabled "
"<pyvista.plotting.themes._TrameConfig.server_proxy_enabled>`"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:106
msgid ""
":py:attr:`pyvista.global_theme.trame.server_proxy_prefix "
"<pyvista.plotting.themes._TrameConfig.server_proxy_prefix>`"
msgstr ""
":py:attr:`pyvista.global_theme.trame.server_proxy_prefix "
"<pyvista.plotting.themes._TrameConfig.server_proxy_prefix>`"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:109
msgid ""
"The default for ``server_proxy_prefix`` is ``'/proxy/'`` and this should be "
"sufficient for most remote Jupyter environment and use within Docker."
msgstr ""
"``server_proxy_prefix`` のデフォルトは ``'/proxy/'`` "
"で，ほとんどのリモートJupyter環境とDocker内での使用にはこれで十分でしょう．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:112
msgid "This can also be set with an environment variable:"
msgstr "これは，環境変数で設定することもできます:"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:119
msgid "The prefix will need to be modified for JupyterHub deployments."
msgstr "JupyterHubにデプロイする場合は，プレフィックスを修正する必要があります．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:121
msgid ""
"On MyBinder, the ``JUPYTERHUB_SERVICE_PREFIX`` string often needs to prefix "
"``'/proxy/'``. This makes it so the prefix includes the users ID in the URL."
" In PyVista, we automatically check for the presence of this variable and "
"prepend it to the ``server_proxy_prefix``."
msgstr ""
"これにより，プレフィックスにユーザIDがURLに含まれるようになります．PyVistaでは，この変数があるかどうかを自動的にチェックし， "
"``server_proxy_prefix`` の前に追加します．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:128
msgid "Trame Jupyter Extension"
msgstr "Trame Jupyterエクステンション"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:130
msgid ""
"`Trame Jupyter Extension <https://github.com/Kitware/trame-jupyter-"
"extension/>`_ enables the trame server and client to communicate over the "
"existing `Jupyter Comms <https://jupyter-"
"notebook.readthedocs.io/en/4.x/comms.html>`_ infrastructure, instead of "
"creating a separate WebSocket connection."
msgstr ""
"`Trame Jupyter Extension <https://github.com/Kitware/trame-jupyter-"
"extension/>`_ は， WebSocket接続を個別に作成する代わりに，既存の `Jupyter Comms "
"<https://jupyter-notebook.readthedocs.io/en/4.x/comms.html>`_ "
"インフラストラクチャ上でtrameサーバーとクライアントの通信を可能にします．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:135
msgid ""
"Using this extension removes the need for a secondary web server and thus "
"``jupyter-server-proxy``."
msgstr "この拡張機能を使用すると，2次ウェブサーバーとした ``jupyter-server-proxy`` の必要性がなくなります．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:138
msgid "Using pip, you can install the extension:"
msgstr "pipを使って，拡張機能をインストールすることができます:"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:144
msgid ""
"If using Jupyter Lab 3.x, make sure to install the version 1.x of the "
"extension:"
msgstr "Jupyter Lab 3.x を使用する場合は，拡張機能のバージョン 1.x をインストールしてください．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:150
msgid ""
"Once the extension is installed, you can select whether PyVista will use it "
"by setting the following flag to ``True`` or ``False``:"
msgstr ""
"拡張機能がインストールされたら，次のフラグを``True`` または ``False`` "
"に設定することで，PyVistaがそれを使用するかどうかを選択できます．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:153
#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:167
msgid ""
":py:attr:`pyvista.global_theme.trame.jupyter_extension_enabled "
"<pyvista.plotting.themes._TrameConfig.jupyter_extension_enabled>`"
msgstr ""
":py:attr:`pyvista.global_theme.trame.jupyter_extension_enabled "
"<pyvista.plotting.themes._TrameConfig.jupyter_extension_enabled>`"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:158
msgid "Setting Remote Jupyter Host with an Environment Variable"
msgstr "環境変数によるリモートJupyterホストの設定"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:159
msgid ""
"You can set the Remote Jupyter Host manually with the flags discussed above,"
" but these need to be set every time the Jupyter kernel restarts. In some "
"environments, it may be more efficient to configure the Remote Jupyter Host "
"with an environment variable. If set, the value for "
"``PYVISTA_TRAME_JUPYTER_MODE`` will determine the values of these two flags:"
msgstr ""
"リモートJupyterホストを上記で説明したフラグを使って手動で設定することもできますが、これらはJupyterカーネルが再起動するたびに設定する必要があります。環境変数でリモートJupyterホストを設定する方が効率的な場合もあります。もし設定されていれば、"
" ``PYVISTA_TRAME_JUPYTER_MODE`` の値がこれら2つのフラグの値を決定します。"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:170
msgid ""
"If set, the accepted values for ``PYVISTA_TRAME_JUPYTER_MODE`` include "
"``'extension'``, ``'proxy'``, and ``'native'``. The following table shows "
"how each accepted value will affect the two flags, as well as any "
"precondition that must be true for the value to be applicable. To meet these"
" prerequisites, review the sections above for installation instructions."
msgstr ""
"設定されている場合、 ``PYVISTA_TRAME_JUPYTER_MODE`` に指定できる値は ``'extension'`` , "
"``'proxy'`` , ``'native'`` "
"です。以下の表は、それぞれの値が2つのフラグにどのような影響を与えるか、またその値を適用するために真でなければならない前提条件を示しています。"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:178
msgid "``PYVISTA_TRAME_JUPYTER_MODE``"
msgstr "``PYVISTA_TRAME_JUPYTER_MODE``"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:179
msgid "Description"
msgstr "説明"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:180
msgid "Condition"
msgstr "状態"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:181
msgid "`server_proxy_enabled`"
msgstr "`server_proxy_enabled`"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:182
msgid "`jupyter_extension_enabled`"
msgstr "`jupyter_extension_enabled`"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:184
msgid "\"extension\""
msgstr "\"extension\""

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:185
msgid "Use Trame Jupyter Extension"
msgstr "Trame Jupyterエクステンションを使用する"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:186
msgid "Extension must be available"
msgstr "拡張が利用可能であること 。"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:187
#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:194
#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:199
#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:200
msgid "False"
msgstr "False"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:188
#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:193
msgid "True"
msgstr "True"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:190
msgid "\"proxy\""
msgstr "\"proxy\""

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:191
msgid "Use Jupyter Server Proxy"
msgstr "Jupyter サーバープロキシを使用する"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:192
msgid "Proxy must be available"
msgstr "プロキシが利用可能であること 。"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:196
msgid "\"native\""
msgstr "\"native\""

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:197
msgid "Do not use Extension nor Proxy"
msgstr "エクステンションもプロキシも使わない"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:198
msgid "None"
msgstr "None"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:203
msgid "Other Considerations"
msgstr "その他の考慮事項"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:204
msgid "It may be worth using GPU acceleration, see :ref:`gpu_off_screen`."
msgstr "GPUアクセラレーションを使用する価値があるかもしれません． :ref:`gpu_off_screen` を参照してください．"

#: ../../pyvista/doc/source/user-guide/jupyter/trame.rst:206
msgid ""
"If you do not have GPU acceleration, alternatively, an offscreen version "
"using OSMesa libraries and ``vtk-osmesa`` is available:"
msgstr ""
"GPUアクセラレーションがない場合は、OSMesaライブラリと ``vtk-osmesa`` を使用したオフスクリーンバージョンもあります:"

#: ../../pyvista/doc/source/user-guide/optional_features.rst:2
msgid "Optional Features"
msgstr "オプションの依存関係"

#: ../../pyvista/doc/source/user-guide/optional_features.rst:3
msgid ""
"Due to its usage of ``numpy``, the PyVista library plays well with other "
"modules, including ``matplotlib``, ``trimesh``, ``rtree``, and ``pyembree``."
"  The following examples show some optional features included within PyVista"
" that use or combine several modules to perform advanced analyses not "
"normally included within ``VTK``."
msgstr ""
"``pyvista`` モジュールは  ``numpy`` を使用しているため， ``matplotlib`` ， ``trimesh`` ， "
"``rtree`` ， ``pyembree`` などの他のモジュールとの相性が良いです．以下の例は，通常は ``VTK`` "
"に含まれない高度な解析を実行するために，複数のモジュールを使用または結合する PyVista に含まれるオプション機能を示しています．"

#: ../../pyvista/doc/source/user-guide/optional_features.rst:10
msgid "Vectorised Ray Tracing"
msgstr "ベクトルレイトレーシング"

#: ../../pyvista/doc/source/user-guide/optional_features.rst:11
msgid ""
"Perform many ray traces simultaneously with a PolyData Object (requires "
"optional dependencies trimesh, rtree and pyembree)"
msgstr ""
"PolyDataオブジェクトを使用して多数のレイトレースを同時に実行します(オプションの依存関係trimesh，rtree，pyembreeが必要です)"

#: ../../pyvista/doc/source/user-guide/optional_features.rst:62
msgid "Project to Finite Plane"
msgstr "有限平面への投影"

#: ../../pyvista/doc/source/user-guide/optional_features.rst:63
msgid ""
"The following example expands on the vectorized ray tracing example by "
"projecting the :func:`load_random_hills() "
"<pyvista.examples.examples.load_random_hills>` example data to a triangular "
"plane."
msgstr ""
"次の例では，ベクトル化されたレイトレーシングの例を発展させ， :func:`load_random_hills() "
"<pyvista.examples.examples.load_random_hills>` の例のデータを3角形の平面に投影しています．"

#: ../../pyvista/doc/source/user-guide/simple.rst:2
msgid "Basic API Usage"
msgstr "APIの基本的な使用方法"

#: ../../pyvista/doc/source/user-guide/simple.rst:4
msgid ""
"PyVista provides tools to get started with just about any VTK dataset and "
"wrap that object into an easily accessible data object. Whether you are new "
"to the VTK library or a power user, the best place to get started is with "
"PyVista's :func:`pyvista.wrap` and :func:`pyvista.read` functions to either "
"wrap a VTK data object in memory or read a VTK or VTK-friendly file format."
msgstr ""
"PyVistaには，ほぼすべてのVTKデータセットを使い始め，そのオブジェクトを簡単にアクセスできるデータオブジェクトにラップするためのツールが用意されています．VTKライブラリーを初めて使用する場合でもパワーユーザーの場合でも，まずはPyVistaの"
" :func:`pyvista.wrap` および :func:`pyvista.read` "
"関数を使って，VTKデータオブジェクトをメモリーにラップするか，VTKまたはVTKに適したファイルフォーマットを読み取ることから始めるのがベストです．"

#: ../../pyvista/doc/source/user-guide/simple.rst:13
msgid "Wrapping a VTK Data Object"
msgstr "VTKデータオブジェクトのラップ"

#: ../../pyvista/doc/source/user-guide/simple.rst:15
msgid ""
"The wrapping function :func:`pyvista.wrap` is usable from the top level of "
"PyVista. This allows users to quickly wrap any VTK dataset they have as a "
"PyVista object:"
msgstr ""
"ラッピング関数 :func:`pyvista.wrap` "
"はPyVistaのトップレベルから使用できます．これにより，ユーザは持っている任意のVTKデータセットをPyVistaオブジェクトとして素早くラップすることができます．"

#: ../../pyvista/doc/source/user-guide/simple.rst:29
msgid "Reading a VTK File"
msgstr "VTKファイルの読み取り"

#: ../../pyvista/doc/source/user-guide/simple.rst:31
msgid ""
"PyVista provides a convenience function to read VTK file formats into their "
"respective PyVista data objects. Simply call the :func:`pyvista.read` "
"function passing the filename:"
msgstr ""
"PyVistaには，VTKファイル形式をそれぞれのPyVistaデータオブジェクトに読み込むための便利な関数が用意されています．ファイル名を渡して "
":func:`pyvista.read` 関数を呼び出します．"

#: ../../pyvista/doc/source/user-guide/simple.rst:43
msgid "Accessing the Wrapped Data Object"
msgstr "ラップされたデータオブジェクトへのアクセス"

#: ../../pyvista/doc/source/user-guide/simple.rst:45
msgid ""
"Now that you have a wrapped VTK data object, you can start accessing and "
"modifying the dataset. Some of the most common properties to access include "
"the points and point/cell data (the data attributes assigned to the nodes or"
" cells of the mesh respectively)."
msgstr ""
"ラップされたVTKデータオブジェクトができたので，データセットへのアクセスと変更を開始することができます．アクセスする最も一般的なプロパティには，ポイントおよびポイント/セルデータ(メッシュのノードまたはセルにそれぞれ割り当てられたデータアトリビュート)があります．"

#: ../../pyvista/doc/source/user-guide/simple.rst:50
msgid "First, check out some common meta-properties:"
msgstr "まず，一般的なメタプロパティをいくつか見てみましょう．"

#: ../../pyvista/doc/source/user-guide/simple.rst:91
msgid ""
"Access the points by fetching the :attr:`points <pyvista.DataSet.points>` "
"attribute on any PyVista mesh as a :class:`numpy.ndarray`:"
msgstr ""
"ポイントにアクセスするには，任意のPyVistaメッシュの :attr:`points <pyvista.DataSet.points>` 属性を "
":class:`numpy.ndarray` としてフェッチします．"

#: ../../pyvista/doc/source/user-guide/simple.rst:109
msgid ""
"Accessing the different data attributes on the nodes and cells of the mesh "
"is interfaced via dictionaries with callbacks to the VTK object. These "
"dictionaries of the different point and cell arrays can be directly accessed"
" and modified as NumPy arrays. In the example below, we load a dataset, "
"access an array on that dataset, then add some more data:"
msgstr ""
"メッシュのノードとセルのさまざまなデータアトリビュートへのアクセスは，VTKオブジェクトへのコールバックを持つディクショナリを介してインタフェースされます．これらの異なる点配列やセル配列のディクショナリには，NumPy配列として直接アクセスしたり修正することができます．次の例では，データセットを読み込み，そのデータセット上の配列にアクセスし，さらにデータを追加します．"

#: ../../pyvista/doc/source/user-guide/simple.rst:141
msgid "Plotting"
msgstr "プロット"

#: ../../pyvista/doc/source/user-guide/simple.rst:143
msgid ""
"PyVista includes numerous plotting routines that are intended to be "
"intuitive and highly controllable with ``matplotlib`` similar syntax and "
"keyword arguments."
msgstr ""
"PyVistaには，直感的に操作でき， ``matplotlib`` "
"に似た構文やキーワード引数で高度に制御できることを目的とした数多くのプロッティングルーチンが含まれています．"

#: ../../pyvista/doc/source/user-guide/simple.rst:147
msgid ""
"To get started, try out the :func:`pyvista.plot` convenience method that is "
"bound to each PyVista data object."
msgstr ""
"まずは，各PyVistaデータオブジェクトにバインドされている便利な :func:`pyvista.plot` メソッドを試してみてください．"

#: ../../pyvista/doc/source/user-guide/simple.rst:176
msgid ""
"You can also create a plotter object to fine tune the scene. First, "
"instantiate a plotter such as :class:`pyvista.Plotter` or "
":class:`pyvistaqt.BackgroundPlotter`.  The :class:`pyvista.Plotter` will "
"create a rendering window that will pause the execution of the code after "
"calling :func:`show() <pyvista.Plotter.show>`."
msgstr ""
"プロッターオブジェクトを作成して，シーンの微調整を行うこともできます．まず， :class:`pyvista.Plotter` や "
":class:`pyvistaqt.BackgroundPlotter` などのプロッターをインスタンス化します． "
":class:`pyvista.Plotter` は， :func:`show() <pyvista.Plotter.show>` "
"を呼び出した後，コードの実行を一時停止するレンダリングウィンドウを作成します．"

#: ../../pyvista/doc/source/user-guide/simple.rst:193
msgid ""
"Optionally :func:`show() <pyvista.Plotter.show>` can return the last used "
"camera position of the rendering window in case you want to choose a camera "
"position and use it again later. The camera position is also available as "
"the :attr:`camera_position <pyvista.Plotter.camera_position>` attribute of "
"the plotter (even after it's closed)."
msgstr ""
"オプションで :func:`show() <pyvista.Plotter.show>` "
"を使用すると，カメラポジションを選択して後で再度使用したい場合に，レンダリングウィンドウの最後に使用されたカメラポジションを返すことができます．カメラの位置は，プロッタの"
" :attr:`camera_position <pyvista.Plotter.camera_position>` "
"属性としても利用できます（プロッタが閉じられた後でも）．"

#: ../../pyvista/doc/source/user-guide/simple.rst:200
msgid ""
"You can then use this cached camera position for additional plotting without"
" having to manually interact with the plotting window:"
msgstr "このキャッシュされたカメラ位置は，プロットウィンドウを手動で操作しなくても，追加のプロットに使用できます:"

#: ../../pyvista/doc/source/user-guide/simple.rst:213
msgid ""
"Be sure to check out all the available plotters and their options for your "
"use case:"
msgstr "使用する用途に応じて，使用可能なすべてのプロッタとオプションを確認してください．"

#: ../../pyvista/doc/source/user-guide/simple.rst:216
msgid ""
":class:`pyvista.Plotter`: The standard plotter that pauses the code until "
"closed."
msgstr ":class:`pyvista.Plotter`: 閉じるまでコードを一時停止する標準的なプロッタです．"

#: ../../pyvista/doc/source/user-guide/simple.rst:218
msgid ""
":class:`pyvistaqt.BackgroundPlotter`: Creates a rendering window that is "
"interactive and does not pause the code execution (for more information see "
"the `pyvistaqt`_ library)"
msgstr ""
":class:`pyvistaqt.BackgroundPlotter`:  "
"インタラクティブで，コードの実行を一時停止しないレンダリングウィンドウを作成します(詳細は `pyvistaqt`_ ライブラリを参照してください)．"

#: ../../pyvista/doc/source/user-guide/simple.rst:227
msgid "Exporting"
msgstr "出力"

#: ../../pyvista/doc/source/user-guide/simple.rst:229
msgid ""
"Any PyVista mesh object can be saved to a VTK file format using "
":func:`save() <pyvista.DataObject.save>`. For example, the mesh in the code "
"block above could be saved like:"
msgstr ""
"どんなPyVistaメッシュオブジェクトでも， :func:`save() <pyvista.DataObject.save>` "
"を使ってVTKファイルフォーマットに保存することができます．例えば，上のコードブロックのメッシュは次のように保存できます．"

#: ../../pyvista/doc/source/user-guide/simple.rst:237
msgid ""
"Or since that mesh is :class:`pyvista.PolyData`, we could use the ``.vtp``, "
"``.stl``, or ``.ply`` formats as well. For more details on which formats are"
" supported in the ``.save()`` method, please refer to the docs for that "
"method on each mesh type."
msgstr ""
"または，メッシュが :class:`pyvista.PolyData` であるため， ``.vtp`` ， ``.stl`` ，または ``.ply``"
" 形式も使用できます． ``.save()`` "
"メソッドでサポートされている形式の詳細については，各メッシュタイプのメソッドに関するドキュメントを参照してください．"

#: ../../pyvista/doc/source/user-guide/simple.rst:242
msgid ""
"Also note that we can export any PyVista mesh to any file format supported "
"by `meshio <https://github.com/nschloe/meshio>`_. Meshio supports many "
"formats including: Abaqus, Ansys msh, AVS-UCD, CGNS, DOLFIN XML, Exodus, "
"FLAC3D, H5M, Kratos/MDPA, Medit, MED/Salome, Gmsh (versions 2 and 4), OBJ, "
"OFF, PERMAS, PLY, STL, TetGen .node/.ele, SVG (2D only, output only), UGRID,"
" WKT (TIN), XDMF, and more."
msgstr ""
"また，任意のPyVistaメッシュを `meshio <https://github.com/nschloe/meshio>`_ "
"でサポートされている任意のファイル形式に書き出すことができます．Meshioは，Abaqus，Ansys msh，AVS-UCD，CGNS，DOLFIN"
" XML，Exodus，FLAC 3 D，H 5 M，Kratos/MDPA，Medit，MED/Salome，Gmsh "
"(バージョン2および4)，OBJ，OFF，PERMAS，PLY，STL，TetGen .node/.ele，SVG (2Dのみ，出力のみ)，UGRID,"
" WKT (TIN)，XDMFなど，多くの形式をサポートしています!"

#: ../../pyvista/doc/source/user-guide/simple.rst:249
msgid ""
"To save a PyVista mesh using ``meshio``, use :func:`pyvista.save_meshio`:"
msgstr ""
"``meshio`` を使用してPyVistaメッシュを保存するには， :func:`pyvista.save_meshio` を使用します:"

#: ../../pyvista/doc/source/user-guide/themes.rst:4
msgid "Plotting Themes"
msgstr "プロットテーマ"

#: ../../pyvista/doc/source/user-guide/themes.rst:6
msgid ""
"PyVista plotting parameters can be controlled on a plot by plot basis or "
"through a global theme, making it possible to control mesh colors and styles"
" through one global configuration."
msgstr ""
"PyVistaのプロットパラメータはプロット単位またはグローバルテーマで制御でき，1つのグローバル設定でメッシュの色とスタイルを制御できます．"

#: ../../pyvista/doc/source/user-guide/themes.rst:10
msgid ""
"The default theme parameters in PyVista can be accessed and displayed with:"
msgstr "PyVistaのデフォルトのテーマパラメータにアクセスして表示するには，以下のようにします:"

#: ../../pyvista/doc/source/user-guide/themes.rst:17
msgid ""
"Default plotting parameters can be accessed individually by their attribute "
"names:"
msgstr "デフォルトのプロットパラメータには，属性名を使用して個別にアクセスできます．"

#: ../../pyvista/doc/source/user-guide/themes.rst:24
msgid ""
"Here's an example plot of the Stanford Dragon using default plotting "
"parameters:"
msgstr "以下は，デフォルトのプロットパラメータを使用したスタンフォードドラゴンのプロット例です．"

#: ../../pyvista/doc/source/user-guide/themes.rst:35
msgid "These parameters can then be modified globally with:"
msgstr "これらのパラメータは，次の方法でグローバルに変更できます．"

#: ../../pyvista/doc/source/user-guide/themes.rst:44
msgid "Now, the mesh will be plotted with the new global parameters:"
msgstr "次に，新しいグローバルパラメータを使用してメッシュをプロットします．"

#: ../../pyvista/doc/source/user-guide/themes.rst:51
msgid "This is identical to plotting the mesh with the following parameters:"
msgstr "これは，次のパラメータを使用してメッシュをプロットすることと同じです．"

#: ../../pyvista/doc/source/user-guide/themes.rst:62
msgid "Creating A Custom Theme"
msgstr "カスタム・テーマの作成"

#: ../../pyvista/doc/source/user-guide/themes.rst:63
msgid ""
"You can customize a theme based on one of the built-in themes and then apply"
" it globally with:"
msgstr "組み込みテーマの1つに基づいてテーマをカスタマイズし，次の方法でグローバルに適用できます．"

#: ../../pyvista/doc/source/user-guide/themes.rst:78
msgid "Alternatively, you can save the theme to disk to be used later with:"
msgstr "または，テーマをディスクに保存して，後で使用することもできます．"

#: ../../pyvista/doc/source/user-guide/themes.rst:84
msgid "And then subsequently loaded in a new session of pyvista with:"
msgstr "その後，次のコマンドを使用して新しいpyvistaセッションにロードします．"

#: ../../pyvista/doc/source/user-guide/themes.rst:92
msgid "Theme API"
msgstr "テーマAPI"

#: ../../pyvista/doc/source/user-guide/themes.rst:93
msgid "See :ref:`theme_api` for the full API definition."
msgstr "完全なAPIの定義については， :ref:`theme_api` を参照してください．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:5
msgid "Transitioning from VTK to PyVista"
msgstr "VTKからPyVistaへの移行"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:6
msgid ""
"VTK is primarily developed in C++ and uses chained setter and getter "
"commands to access data. Instead, PyVista wraps the VTK data types into "
"numpy arrays so that users can benefit from its bracket syntax and fancy "
"indexing. This section demonstrates the difference between the two "
"approaches in a series of examples."
msgstr ""
"VTKは主にC++で開発されており，データへのアクセスには連鎖したセッターとゲッターのコマンドを使用します．その代わりに，PyVista は VTK "
"のデータタイプを numpy 配列にラップして，ブラケット構文や派手なインデックスの恩恵を受けられるようにしています． "
"このセクションでは，一連の例で2つのアプローチの違いを説明します．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:12
msgid ""
"For example, to hard-code points for a :vtk:`vtkImageData` data structure "
"using VTK Python's bindings, one would write the following:"
msgstr ""
"たとえば，VTK Pythonのバインディングを使って，  :vtk:`vtk.vtkImageData` "
"データ構造のポイントをハードコーディングするには，次のように書きます．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:46
msgid ""
"As you can see, there is quite a bit of boilerplate that goes into the "
"creation of a simple :vtk:`vtkImageData` dataset. PyVista provides much more"
" concise syntax that is more \"Pythonic.\" The equivalent code in PyVista "
"is:"
msgstr ""
"ご覧のように，単純な  :vtk:`vtk.vtkImageData` "
"データセットを作成するためには，かなり多くのボイラープレートが必要です．PyVistaでは，より簡潔で，より \"Pythonic "
"\"な構文が提供されています．PyVistaで同等のコードは以下の通りです．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:69
msgid "Here, PyVista has done several things for us:"
msgstr "ここでは，PyVistaがいくつかのことをしてくれています．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:71
msgid ""
"PyVista combines the dimensionality of the data (in the shape of the "
":class:`numpy.ndarray`) with the values of the data in one line. VTK uses "
"\"tuples\" to describe the shape of the data (where it sits in space) and "
"\"components\" to describe the type of data (1 = scalars/scalar fields, 2 = "
"vectors/vector fields, n = tensors/tensor fields). Here, shape and values "
"are stored concretely in one variable."
msgstr ""
"PyVistaでは，データの次元（ :class:`numpy.ndarray` "
"の形をしている）とデータの値を1行にまとめています．VTKでは，データの形状(空間上の位置)を表すために \"タプル\" "
"を使用し，データの種類(1=スカラー/スカラーフィールド，2=ベクトル/ベクトルフィールド，n=テンソル/テンソルフィールド)を表すために "
"\"コンポーネント\" を使用しています．ここでは，1つの変数に形状と値が具体的に格納されています．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:79
msgid ""
":class:`pyvista.ImageData` wraps :vtk:`vtkImageData`, just with a different "
"name; they are both containers of evenly spaced points. Your data does not "
"have to be an \"image\" to use it with :vtk:`vtkImageData`; rather, like "
"images, values in the dataset are evenly spaced apart like pixels in an "
"image."
msgstr ""
":class:`pyvista.UniformGrid` は  :vtk:`vtk.vtkImageData` "
"をラップしたものです．名前が違うだけで，どちらも等間隔の点のコンテナです．  :vtk:`vtk.vtkImageData`_ で使用するデータは "
"\"画像\" である必要はありません．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:85
msgid ""
"Furthermore, since we know the container is for uniformly spaced data, "
"pyvista sets the origin and spacing by default to ``(0, 0, 0)`` and ``(1, 1,"
" 1)``. This is another great thing about PyVista and Python. Rather than "
"having to know everything about the VTK library up front, you can get "
"started very easily. Once you get more familiar with it and need to do "
"something more complex, you can dive deeper. For example, changing the "
"origin and spacing is as simple as:"
msgstr ""
"さらに，コンテナが等間隔のデータ用であることがわかっているので， pyvista はデフォルトで原点と間隔を ``(0, 0, 0)`` と ``(1,"
" 1, 1)`` "
"に設定します．これは，PyVistaとPythonのもう一つの素晴らしい点です．VTKライブラリのすべてを前もって知っておく必要はなく，非常に簡単に始めることができます．慣れてきて，もっと複雑なことをする必要が出てきたら，もっと深く掘り下げることができます．例えば，原点と間隔の変更は以下のように簡単にできます．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:98
msgid ""
"The name for the :attr:`point_array <pyvista.point_array>` is given directly"
" in dictionary-style fashion. Also, since VTK stores data on the heap "
"(linear segments of RAM; a C++ concept), the data must be flattened and put "
"in Fortran ordering (which controls how multidimensional data is laid out in"
" physically 1D memory; numpy uses \"C\"-style memory layout by default). "
"This is why in our earlier example, the first argument to ``SetValue()`` was"
" written as ``x*300 + y``. Here, numpy takes care of this for us quite "
"nicely and it's made more explicit in the code, following the Python best "
"practice of \"Explicit is better than implicit.\""
msgstr ""
":attr:`point_array <pyvista.point_array>` "
"の名前は，辞書形式で直接与えられます．また，VTKはデータをヒープ(RAMの線形セグメント．C++の概念)に保存するため，データをフラット化してFortranの順序(多次元データが物理的に1次元のメモリにどのようにレイアウトされるかを制御する．numpyはデフォルトで"
" \"C \"スタイルのメモリレイアウトを使用する)にする必要があります．先ほどの例で， ``SetValue()`` の最初の引数が ``x*300 "
"+ y`` と書かれていたのはこのためです．ここでは，numpyがこれをうまく処理してくれるので，Pythonのベストプラクティスである "
"\"Explicit is better than implicit\" に従って，コードの中でより明示的にしています．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:109
msgid ""
"Finally, with PyVista, each geometry class contains methods that allow you "
"to immediately plot the mesh without also setting up the plot. For example, "
"in VTK you would have to do:"
msgstr ""
"最後に，PyVistaでは，各ジオメトリクラスにメソッドが用意されているので，プロットの設定をしなくても，すぐにメッシュをプロットすることができます．例えば，VTKでは次のようにする必要があります．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:128
msgid "However, with PyVista you only need:"
msgstr "しかし，PyVistaでは，必要なのは以下だけです:"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:156
msgid "PointSet Construction"
msgstr "ポイントセット構築"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:157
msgid ""
"PyVista heavily relies on NumPy to efficiently allocate and access VTK's C "
"arrays. For example, to create an array of points within VTK one would "
"normally loop through all the points of a list and supply that to a  "
":vtk:`vtkPoints` class. For example:"
msgstr ""
"PyVista は，VTK の C 配列を効率的に割り当て，アクセスするために NumPy に大きく依存しています． "
"例えば，VTKで点の配列を作るには，通常，リストのすべての点をループして，それを  :vtk:`vtkPoints` クラスに供給します． "
"例えば，以下のようになります．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:181
msgid ""
"To do the same within PyVista, you simply need to create a NumPy array:"
msgstr "PyVistaで同じことをするには，単にNumPyの配列を作成する必要があります．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:189
msgid ""
"You can use :func:`pyvista.vtk_points` to construct a :vtk:`vtkPoints` "
"object, but this is unnecessary in almost all situations."
msgstr ""
":func:`pyvista.vtk_points` を使って :vtk:`vtkPoints` "
"オブジェクトを構築することもできますが，ほとんどの状況では必要ありません．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:192
msgid ""
"Since the end goal is to construct a :class:`pyvista.DataSet "
"<pyvista.core.dataset.DataSet>`, you would simply pass the ``np_points`` "
"array to the :class:`pyvista.PolyData` constructor:"
msgstr ""
"最終的な目的は， :class:`pyvista.DataSet <pyvista.core.dataset.DataSet>` を構築することなので，"
" :class:`pyvista.PolyData` のコンストラクタに ``np_points`` の配列を渡すだけです．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:201
msgid "Whereas in VTK you would have to do:"
msgstr "VTKではそうする必要があります．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:208
msgid ""
"The same goes with assigning face or cell connectivity/topology. With VTK "
"you would normally have to loop using ``InsertNextCell`` and "
"``InsertCellPoint``. For example, to create a single cell (triangle) and "
"then assign it to :vtk:`vtkPolyData`:"
msgstr ""
"面やセルの接続性/トポロジーを割り当てる場合も同様です． VTKでは通常， ``InsertNextCell`` と "
"``InsertCellPoint`` を使ってループする必要があります． 例えば，一つのセル(3角形)を作成して，それを  "
":vtk:`vtkPolyData` に割り当てる場合:"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:222
msgid ""
"In PyVista, we can assign this directly in the constructor and then access "
"it (or change it) from the :attr:`faces <pyvista.PolyData.faces>` attribute."
msgstr ""
"PyVistaでは，コンストラクタでこれを直接割り当て， :attr:`faces <pyvista.PolyData.faces>` "
"属性からアクセス（変更）することができます．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:235
msgid "Object Representation"
msgstr "オブジェクトの表現"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:236
msgid "Both VTK and PyVista provide representations for their objects."
msgstr "VTKもPyVistaもオブジェクトの表現を提供しています．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:238
msgid ""
"VTK provides a verbose representation (useful for debugging) of their data "
"types that can be accessed via :func:`print`, as the ``__repr__`` (unlike "
"``__str__``) only provides minimal information about each object:"
msgstr ""
"VTK は :func:`print` でアクセスできるデータ型の詳細な表現を提供しています(デバッギングに便利)．これは ``__repr__`` が"
" ( ``__str__`` とは異なり) 各オブジェクトに関する最小限の情報しか提供していないためです．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:246
msgid ""
"PyVista chooses to show minimal data in the :func:`repr`, preferring "
"explicit attribute access on meshes for the bulk of attributes. For example:"
msgstr ""
"PyVista は :func:`repr` "
"で最小限のデータを表示することにしており，アトリビュートの大部分はメッシュ上の明示的なアトリビュートアクセスを優先しています．例えば，以下のようになります．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:261
msgid ""
"All other attributes like :attr:`lines <pyvista.PolyData.lines>`, "
":attr:`point_data <pyvista.DataSet.point_data>`, or :attr:`cell_data "
"<pyvista.DataSet.cell_data>` can be accessed directly from the object. This "
"approach was chosen to allow for a brief summary showing key parts of the "
":class:`DataSet <pyvista.DataSet>` without overwhelming the user."
msgstr ""
":attr:`lines <pyvista.PolyData.lines>`， :attr:`point_data "
"<pyvista.DataSet.point_data>`， :attr:`cell_data <pyvista.DataSet.cell_data>`"
" などの他のすべての属性は，オブジェクトから直接アクセスすることができます． このアプローチは，ユーザーを圧倒することなく， "
":class:`DataSet <pyvista.DataSet>` の重要な部分を示す簡単な要約を可能にするために選ばれました．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:269
msgid "Tradeoffs"
msgstr "トレードオフ"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:270
msgid ""
"While most features can, not everything can be simplified without losing "
"functionality or performance."
msgstr "ほとんどの機能は可能ですが，機能や性能を損なわずにすべてを簡素化できるわけではありません．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:273
msgid ""
"In the :class:`collision <pyvista.PolyDataFilters.collision>` filter, we "
"demonstrate how to calculate the collision between two meshes. For example:"
msgstr ""
":class:`collision <pyvista.PolyDataFilters.collision>` "
"フィルターでは，2つのメッシュ間のコリジョンを計算する方法を示します． 例えば，以下のようになります．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:305
msgid ""
"Under the hood, the collision filter detects mesh collisions using oriented "
"bounding box (OBB) trees. For a single collision, this filter is as "
"performant as the VTK counterpart, but when computing multiple collisions "
"with the same meshes, as in the :ref:`collision_example` example, it is more"
" efficient to use the :vtk:`vtkCollisionDetectionFilter`, as the OBB tree is"
" computed once for each mesh. In most cases, pure PyVista is sufficient for "
"most data science, but there are times when you may want to use VTK classes "
"directly."
msgstr ""
"フードの下では，コリジョンフィルタは OBB (oriented bounding box) ツリーを使ってメッシュの衝突を検出します． しかし， "
":ref:`collision_example` "
"の例のように，同じメッシュで複数の衝突を計算する場合には，OBBツリーが各メッシュに対して一度ずつ計算されるため，  "
":vtk:`vtkCollisionDetectionFilter` を使用した方が効率的です． "
"ほとんどのデータサイエンスでは，純粋なPyVistaで十分ですが，VTKクラスを直接使用したい場合もあります．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:314
msgid ""
"Note that nothing stops you from using VTK classes and then wrapping the "
"output with PyVista. For example:"
msgstr ""
"VTKクラスを使用して，その出力をPyVistaでラッピングすることを妨げるものは何もないことに注意してください． 例えば，以下のようになります．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:334
msgid ""
"In this manner, you can get the \"best of both worlds\" should you need the "
"flexibility of PyVista and the raw power of VTK."
msgstr ""
"このようにして， PyVistaの柔軟性とVTKの原動力の両方を必要とする \"best of both worlds\" を得ることができるのです．"

#: ../../pyvista/doc/source/user-guide/vtk_to_pyvista.rst:338
msgid ""
"You can use :func:`pyvista.Polygon` for a one line replacement of the above "
"VTK code."
msgstr "上記のVTKコードを1行で置き換えるために， :func:`pyvista.Polygon` を使用することができます．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:4
msgid "What is a Mesh?"
msgstr "メッシュとは?"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:5
msgid ""
"In PyVista, a mesh is any spatially referenced information and usually "
"consists of geometrical representations of a surface or volume in 3D space. "
"We commonly refer to any spatially referenced dataset as a mesh, so often "
"the distinction between a mesh, a grid, and a volume can get fuzzy, but that"
" does not matter in PyVista. If you have a dataset that is a surface mesh "
"with 2D geometries like triangles, we call it a mesh, and if you have a "
"dataset with 3D geometries like voxels, tetrahedra, hexahedra, etc., then we"
" also call that a mesh. Why? Because it is simple that way."
msgstr ""
"PyVistaでは，メッシュは空間的に参照される情報であり，通常は3 "
"D空間内の表面またはボリュームのジオメトリ表現で構成されます．一般的に，空間的に参照されるデータセットはメッシュと呼ばれるため，メッシュ，グリッド，ボリュームの区別があいまいになることがありますが，PyVistaでは関係ありません．3角形のような2"
" Dジオメトリを持つ表面メッシュのデータセットがある場合はメッシュと呼び，ボクセル，4面体，6面体などの3 "
"Dジオメトリのデータセットがある場合はメッシュと呼びます．なぜか? その方が簡単だからです．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:15
msgid ""
"In all spatially referenced datasets, there lies an underlying mesh "
"structure which is the connectivity between vertices to define cells. "
"Whether those cells are 2D or 3D is not always of importance and we've "
"worked hard to make PyVista work for datasets of either or mixed geometries "
"so that you as a user do not have to get bogged down in the nuances."
msgstr ""
"空間的に参照されるすべてのデータセットには，セルを定義する頂点間の接続またはジオメトリである基礎となるメッシュ構造が存在します．これらのセルが2 "
"Dであるか3 "
"Dであるかは常に重要ではなく，ユーザがニュアンスにとらわれないように，いずれかのジオメトリまたは混合ジオメトリのデータセットでPyVistaを動作させるために私たちは懸命に努力してきました．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:22
msgid ""
"This is a very high level overview of the PyVista API. For further details "
"regarding our data model and how it relates to the underlying VTK data "
"model, please see :ref:`pyvista_data_model`."
msgstr ""
"これは，PyVista APIの非常に高いレベルの概要です． PyVistaのデータモデルの詳細や，基礎となるVTKデータモデルとの関連性については， "
":ref:`pyvista_data_model` をご覧ください．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:28
msgid "What is a Point?"
msgstr "ポイントとは？"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:29
msgid ""
"Points are the vertices of the mesh, also referred to as the Cartesian "
"coordinates of the underlying structure. All PyVista datasets (meshes) have "
"points and sometimes, you can have a mesh that only has points, like a point"
" cloud."
msgstr ""
"ポイントはメッシュの頂点，つまり基礎となる直交座標です．すべてのPyVistaデータセット (メッシュ) "
"にはポイントがあり，場合によっては，ポイントクラウドのようにポイントのみを持つメッシュを作成できます．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:34
msgid ""
"For example, you can create a point cloud mesh using the "
":class:`pyvista.PolyData` class which is built for meshes that have 1D and "
"2D cell types (we'll get into what a cell is briefly)."
msgstr ""
"たとえば，1 Dおよび2 Dのセルタイプ(セルとは何か簡単に説明します)を持つメッシュ用に作成された :class:`pyvista.PolyData`"
" クラスを使用して，ポイントクラウドメッシュを作成できます．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:38
msgid ""
"Let's start with a point cloud; this is a mesh type that only has vertices. "
"You can create one by defining a 2D array of Cartesian coordinates like so:"
msgstr "ポイントクラウドから始めましょう;これは頂点のみを持つメッシュタイプです．作成するには，2 D配列の直交座標を次のように定義します．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:67
msgid ""
"But it's important to note that most meshes have some sort of connectivity "
"between points such as this gridded mesh:"
msgstr "ただし，ほとんどのメッシュは，次のグリッド化されたメッシュなどのポイント間で何らかの接続性を持っていることに注意してください．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:87
msgid "Or this triangulated surface:"
msgstr "または，この3角形表面:"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:106
msgid "What is a Cell?"
msgstr "セルとは?"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:107
msgid ""
"A cell is the geometry between points that defines the connectivity or "
"topology of a mesh. In the examples above, cells are defined by the lines "
"(edges colored in black) connecting points (colored in red). For example, a "
"cell in the beam example is a voxel defined by the region between eight "
"points in that mesh:"
msgstr ""
"セルは，メッシュの接続またはトポロジを定義するポイント間のジオメトリです．上記の例では，セルはポイント(赤色をしている)を結ぶ線(黒色をしているエッジ)によって定義されます．たとえば，ビームの例のセルは，メッシュ内の8つのポイント間の領域によって定義されるボクセルです．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:132
msgid ""
"Cells aren't limited to voxels, they could be a triangle between three "
"points, a line between two points, or even a single point could be its own "
"cell (but that's a special case)."
msgstr ""
"セルはボクセルに限定されず，3つのポイント間の3角形，2つのポイント間のライン，または1つのポイント自体のセル(これは特別なケースです)にすることができます．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:138
msgid "What are Attributes?"
msgstr "アトリビュートとは?"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:139
msgid ""
"Attributes are data values that live on either the points or cells of a "
"mesh. In PyVista, we work with both point data and cell data and allow easy "
"access to data dictionaries to hold arrays for attributes that live either "
"on all points or on all cells of a mesh. These attributes can be accessed in"
" a Dictionary-like attribute attached to any PyVista mesh accessible as one "
"of the following:"
msgstr ""
"アトリビュートは，メッシュのポイントまたはセルに存在するデータ値です．PyVistaでは，ポイントデータとセルデータの両方を処理し，データ辞書に簡単にアクセスして，メッシュのすべてのポイントまたはすべてのセルに存在するアトリビュートの配列を保持できます．これらの属性は，以下のようにアクセスできるPyVistaメッシュに付けられた辞書のような属性にアクセスできます．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:146
msgid ":attr:`point_data <pyvista.DataSet.point_data>`"
msgstr ":attr:`point_data <pyvista.DataSet.point_data>`"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:147
msgid ":attr:`cell_data <pyvista.DataSet.cell_data>`"
msgstr ":attr:`cell_data <pyvista.DataSet.cell_data>`"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:148
msgid ":attr:`field_data <pyvista.DataObject.field_data>`"
msgstr ":attr:`field_data <pyvista.DataObject.field_data>`"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:152
msgid ""
"Point data refers to arrays of values (scalars, vectors, etc.) that live on "
"each point of the mesh. Each element in an attribute array corresponds to a "
"point in the mesh. Let's create some point data for the beam mesh. When "
"plotting, the values between points are interpolated across the cells."
msgstr ""
"ポイントデータは，メッシュの各ポイント上に存在する値の配列(スカラー，ベクトルなど．)を参照します．アトリビュート配列の各要素は，メッシュ内のポイントに対応している必要があります．ビームメッシュの点データを作成します．ポイント間の値をプロットすると，セル間で補間されます．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:166
msgid ""
"Cell data refers to arrays of values (scalars, vectors, etc.) that live "
"throughout each cell of the mesh. That is the entire cell (2D face or 3D "
"volume) is assigned the value of that attribute."
msgstr ""
"セルデータは，メッシュの各セル全体に存在する値の配列(スカラー，ベクトルなど)を参照します．つまり，セル全体(2 D面または3 "
"D体積)にそのアトリビュートの値が割り当てられます．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:176
msgid ""
"Here's a comparison of point data versus cell data and how point data is "
"interpolated across cells when mapping colors. This is unlike cell data "
"which has a single value across the cell's domain:"
msgstr ""
"ここでは，点データとセルデータを比較し，色をマッピングするときに点データがセル間でどのように補間されるかを示します．これは，セルのドメイン全体で単一の値を持つセルデータとは異なります．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:199
msgid ""
"Field data is not directly associated with either the points or cells but "
"still should be attached to the mesh. This may be a string array storing "
"notes, or even indices of a :ref:`collision_example`."
msgstr ""
"フィールドデータはポイントやセルとは直接関連していませんが，メッシュに添付する必要があります． これはメモを格納した文字列の配列であったり，あるいは "
":ref:`collision_example` のインデックスであったりします．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:207
msgid "Assigning Scalars to a Mesh"
msgstr "スカラーをメッシュに割り当てる"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:209
msgid ""
"Here's how we assign values to cell attributes and plot it. Here, we "
"generate cube containing 6 faces and assign each face an integer from "
"``range(6)`` and then have it plotted."
msgstr ""
"ここでは，セルの属性に値を割り当て，それをプロットする方法を紹介します． ここでは，6つの面を含む立方体を生成し，それぞれの面に "
"``range(6)`` から整数を割り当てて，それをプロットしています．"

#: ../../pyvista/doc/source/user-guide/what-is-a-mesh.rst:213
msgid "Note how this varies from assigning scalars to each point"
msgstr "これは，各点にスカラーを割り当てるのとは異なることに注意してください．"
